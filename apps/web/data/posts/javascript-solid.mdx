---
title: "Principios SOLID en JavaScript"
tags:
  - " Desarrollo"
date: "2023-10-16"
---

## TL;DR:

驴Eres m谩s de contenido en v铆deo? Aqu铆 tienes explicados los 5 principios SOLID de la programaci贸n, aplicado a JavaScript.

<YouTube videoId="6PdAOfsPh48" />

En este art铆culo discutiremos los principios SOLID, una serie de pautas muy 煤tiles para mejorar tu c贸digo en programaci贸n orientada a
objetos. Estos principios fueron popularizados por Robert C. Martin, conocido como el "t铆o Bob", autor de libros como *Clean Code*.

## Introducci贸n a SOLID - Qu茅 son y Por Qu茅 Importan

Los principios SOLID son un acr贸nimo de cinco valores de dise帽o:

1. **Single Responsibility Principle** (S) - Principio de Responsabilidad nica
2. **Open-Closed Principle** (O) - Principio de Abierto/Cerrado
3. **Liskov Substitution Principle** (L) - Principio de Sustituci贸n de Liskov
4. **Interface Segregation Principle** (I) - Principio de Segregaci贸n de la Interfaz
5. **Dependency Inversion Principle** (D) - Principio de Inversi贸n de Dependencias

A continuaci贸n vamos a profundizar en cada uno de estos principios aplic谩ndolos a nuestro lenguaje de programaci贸n favorito: JavaScript.
Empezamos con el primer principio.

## Principio de responsabilidad 煤nica (S)

Seg煤n este principio, una clase debe tener una sola raz贸n para cambiar, es decir, debe tener s贸lo una tarea o responsabilidad.

Para ilustrar este principio, pensemos en una orquesta. Cada m煤sico tiene un instrumento que sabe tocar perfectamente. El violinista
sabe tocar el viol铆n, pero si lo pusi茅ramos a tocar tambi茅n el tambor, seguramente algo no funcionar铆a bien.

<YouTube videoId="HQAjtNPgfss" />

Aplicando este ejemplo a la programaci贸n, cada clase o funci贸n debe tener una 煤nica responsabilidad.
Esto simplifica la comprensi贸n, el mantenimiento y la modificaci贸n del c贸digo en el futuro.

Vamos a ilustrar esto con un ejemplo de un caso que puedes encontrarte en tu d铆a a d铆a como desarrollador.

Considera una funci贸n `calculateSalary()`. Esta funci贸n recibe un objeto que simula a un empleado y calcula su salario.
Pero adem谩s de calcular el salario, esta funci贸n tambi茅n genera un reporte del empleado.

```javascript
function calculateSalary(employee) {
    let salary = employee.hoursWorked * employee.hourlyRate;
    let report = /*...*/;
    console.log(report);
    return salary;
}
```

En esta funci贸n hay dos responsabilidades: calcular el salario y generar el informe. Esto viola el principio de responsabilidad 煤nica.

Una alternativa ser铆a refactorizar esta funci贸n en dos funciones separadas: una para calcular el salario y otra para generar el informe.

```javascript
function calculateSalary(employee) {
    return employee.hoursWorked * employee.hourlyRate;
}

function generateReport(employee, salary) {
    let report = /*...*/;
    console.log(report);
}
```

En esta refactorizaci贸n, cada funci贸n tiene una sola responsabilidad, lo que facilita su comprensi贸n y mantenimiento.


## Principio de abierto-cerrado (O)

El segundo principio SOLID es el principio de abierto-cerrado. Su definici贸n oficial sostiene que las entidades de software (clases, m贸dulos, funciones, etc.) deben estar abiertas para su extensi贸n, pero cerradas para su modificaci贸n.

Para entender este principio, imaginemos un coche de juguete que se carga con bater铆as. El dise帽o del coche est谩 cerrado para modificaciones, no puedes cambiar la forma en que se carga. Sin embargo, est谩 abierto para su extensi贸n, puedes cargarlo con diferentes tipos de bater铆as o pilas.

En el c贸digo, debemos poder agregar nuevas funcionalidades sin modificar el c贸digo que ya existe.

<YouTube videoId="_-O0KOrISKk" />

Imagina, por ejemplo, que tienes una aplicaci贸n de comercio electr贸nico con una funci贸n `processPayment()`, que recibe un monto y los detalles de una tarjeta de cr茅dito. En un principio, este sistema permit铆a s贸lo pagos con tarjeta de cr茅dito.

```javascript
function processPayment(price, cardDetails) {
    /*...*/
    console.log('Pagado con tarjeta.');
}
```

Pero m谩s adelante, decides que tu aplicaci贸n tambi茅n deber铆a aceptar pagos con PayPal. Podr铆as estar tentado a a帽adir l贸gica extra a la funci贸n `processPayment()``, con una condici贸n para verificar si el pago se est谩 haciendo con tarjeta o con PayPal. Pero esto violar铆a el principio de abierto-cerrado, ya que est谩s modificando la funci贸n en lugar de extenderla.

Una mejor soluci贸n ser铆a agregar una nueva funci贸n processPaymentWithPayPal(). De esta manera, puedes manejar los pagos con PayPal sin alterar el c贸digo existente.

```javascript
function processPaymentWithPayPal(price, accountDetails) {
    /*...*/
    console.log('Pagado con PayPal.');
}
```

Al aplicar el principio abierto/cerrado, nos aseguramos de que cada vez que queremos agregar una nueva funcionalidad, como aceptar pagos con Bitcoin, s贸lo necesitamos a帽adir una nueva subclase.



## Principio de Sustituci贸n de Liskov (L)

El principio de sustituci贸n de Liskov establece que "los objetos de una superclase deben ser reemplazables por objetos de una subclase sin afectar la correcci贸n del programa".

Al aplicar este principio, podemos crear diferentes objetos "manejador de errores" que se pueden utilizar en el mismo lugar sin causar errores en el programa.

<YouTube videoId="3raQSxeOflg" />

```javascript
// Funci贸n de ejemplo que realizac una petici贸n HTTP
function makeRequest(url, errorHandler) {
    fetch(url)
        .then(response => response.json())
        .catch(error => errorHandler.handle(error))
    }

// Podemos tener varias funciones para manejar errores
const consoleErrorHandler = function handle(error){
    console.log(error)
}

const externalErrorHandler = function handle(error){
    sendErrorToExternalService(error)
}
// Usando el principio de sustituci贸n de Liskov, 
// podr铆amos pasar cualquier funci贸n manejadora de
// errores durante una request.
makeRequest(url, consoleErrorHandler);
makeRequest(url, externalErrorHandler);
```

## principio de segregaci贸n de la interfaz (I)

El cuarto principio SOLID, la "I", se refiere al principio de segregaci贸n de la interfaz. Con base en este principio, ninguna clase deber铆a ser forzada a implementar interfaces o m茅todos que no va a utilizar.

Es mejor tener interfaces espec铆ficas, en lugar de una sola interfaz general. Y esto aplica tambi茅n a las funciones en JavaScript.

<YouTube videoId="N6TxeHzum_g" />

```javascript
class Product {
    constructor() { /* */ }

    getDetails() { /* */ }
    saveToDb() {/* */ }
    displayInFrontEnd() { /* */ }
}

// DigitalProduct no necesita el m茅todo saveToDb(),
// sin embargo, lo hereda sin poder evitarlo
// Se viola el principio de segregaci贸n de la interfaz

class DigitalProduct extends Product{
    // Se hereda el m茅todo innecesario saveToDb()}
}

// ---- //
// Refactorizando siguiendo este principio

class Product {
    constructor() { /* */ }

    getDetails() { /* */ }
    displayInFrontEnd() { /* */ }
}

class PhysicalProduct extends Product {
    constructor() {
        super()
    }
    saveToDb() { /* */ }
}

class DigitalProduct extends Product{
    // No se hereda el m茅todo innecesario saveToDb()
}
```

## Principio de inversi贸n de dependencia (D)

El 煤ltimo principio, "D", es el principio de inversi贸n de dependencia. Este principio sostiene que los m贸dulos de alto nivel, es decir, los m贸dulos que contienen las decisiones estrat茅gicas y las directivas de alto nivel, no deben depender de los m贸dulos de bajo nivel, que son los m贸dulos que contienen la l贸gica detallada y de bajo nivel.

Ambos, los m贸dulos de alto nivel y de bajo nivel, deber铆an depender de abstracciones.

<YouTube videoId="U4yVna0ZH80" />

Siguiendo el principio de inversi贸n de dependencias, una clase `PasswordReminder` no debe depende directamente de `MySQLConnection`, sino que debe recibir una instancia de una clase que implemente una interfaz com煤n de "conexi贸n de base de datos".

```javascript
class MySqlConnection {
    connect() { /* */ }
}

class PasswordReminder {
    constructor() {
        this.dbConnection = new MySQLConnection();
    }
}

// Refactorizando de acuerdo al principio de inversi贸n de dependencia
class MySqlConnection {
    connect() { /* */ }
}
class PostgreSqlConnection {
    connect() { /* */ }
}

class PasswordReminder {
    constructor(connection) {
        this.dbConnection = connection
    }
}
```


## Reflexiones Finales

Las reglas SOLID son una herramienta muy 煤til para la programaci贸n. Pero, al igual que cualquier herramienta, no deben ser aplicadas ciegamente en todos los casos. Mi consejo es que sigas estos principios donde tenga sentido y pueda ayudarte a mantener y mejorar tu c贸digo en el largo plazo.

> "El software es un ciclo en el que t煤 vas desarrollando c贸digo, se van necesitando nuevas caracter铆sticas o funcionalidades, van apareciendo bugs sin querer o queriendo, y vas a necesitar refactorizar. No necesariamente siempre tienes que estar escribiendo c贸digo nuevo. La mayor parte de tu tiempo vas a estar leyendo c贸digo de otros o incluso tuyo y vas a poder ver que hay partes que puedes refactorizar para mejorar el mantenimiento e incluso el rendimiento de tu aplicaci贸n."

Como siempre, si tienes alguna pregunta o comentario, no dudes en escribirlo abajo. 

隆Hasta la pr贸xima!

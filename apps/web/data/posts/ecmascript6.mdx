---
title: Aprende ECMAScript 6 (ES6 o ES2015), el nuevo est치ndar de JavaScript
date: "2018-10-24"
banner: "/images/ecmascript6//ecmascript6-seo.jpg"
tags:
  - 游눹 Desarrollo
---

**ECMAScript v6** (Abreviado como ES6 o ES2015) es el est치ndar que sigue JavaScript desde Junio de 2015. Hasta ese momento la versi칩n de JS que est치bamos usando en nuestros navegadores y Node.js, era la v5.

## La evoluci칩n de JavaScript

Primero un poco de historia. En 1995 (hace m치s de 20 a침os!) **[Brendan Eich](http://es.wikipedia.org/wiki/Brendan_Eich)** crea un lenguaje llamado **Mocha** cuando trabajaba en **Netscape**. En Septiembre de ese a침o lo renombra a _LiveScript_ hasta que le cambiaron el nombre a _JavaScript_ debido a una estrategia de marketing, ya que Netscape fue adquirida por _Sun Microsystems_, propietaria del lenguaje **Java**, muy popular por aquel entonces.

> **춰Advertencia!**: aclarar lo siguiente `Java != JavaScript`.
>
> ![JavaScript no es Java](/images/ecmascript6/meme-javascrip-java.jpg)

En 1997 se crea un comit칠 (TC39) para estadarizar JavaScript por la _European Computer Manufacturers' Association_, ECMA. Se dise침a el est치ndar del DOM (_Document Object Model_) para evitar incompatibilidades entre navegadores. A partir de entonces los est치ndares de JavaScript se rigen por ECMAScript.

![historia de JavaScript](/images/ecmascript6/cronologia-javascript-1.png)

En 1999 aparece la 3a versi칩n del est치ndar ECMAScript, que se mantendr칤a vigente hasta hace pocos a침os. Hubo peque침os intentos de escribir la versi칩n 4, pero hasta 2011 no se aprob칩 y se estandariz칩 la vers칤on 5 (ES5) que es la que usamos hoy en d칤a.

![historia de javascript](/images/ecmascript6/cronologia-javascript-2.png)

En junio de 2013 qued칩 parado el borrador de la versi칩n 6, pero en Diciembre de 2014 se aprob칩 al fin y se espera su estandarizaci칩n a partir de Junio de 2015.

## Principales novedades de ES6

> **쯈uieres aprender JavaScript desde cero hasta el nuevo est치ndar de ECMAScript 6?** Hazlo con mi ebook [_Aprendiendo JavaScript_](https://leanpub.com/aprendiendo-javascript) que ya tienen m치s de 400 lectores. Cons칤guelo [aqu칤](https://leanpub.com/aprendiendo-javascript)

ES6 trae muchos cambios significativos al lenguaje. Veamos algunos de ellos:

### Funci칩n Arrow

쮺u치ntas veces has programado un c칩digo con una estructura similar a la siguiente?

```javascript
// ES5
// Imaginemos una variable data que incluye un array de objectos
var data = [{...}, {...}, {...}, ...];
data.forEach(function(elem){
	// Tratamos el elemento
    console.log(elem)
});
```

Con la funci칩n _arrow_ `=>` de ES6, el c칩digo anterior se sustituir칤a por:

```javascript
//ES6
var data = [{...}, {...}, {...}, ...];
data.forEach(elem => {
	console.log(elem);
});
```

Mucho m치s limpio y claro. CoffeeScript (un metalenguaje que compila a JavaScript) usa algo parecido.

Incluso la podemos utilizar as칤:

```javascript
// ES5
var miFuncion = function (num) {
  return num + num;
};
```

```javascript
// ES6
var miFuncion = (num) => num + num;
```

### Clases

Ahora JavaScript tendr치 clases, muy parecidas las funciones constructoras de objectos que realizabamos en el est치ndar anterior, pero ahora bajo el paradigma de clases, con todo lo que eso conlleva, como por ejemplo, herencia.
Aunque no deja de ser un _az칰car sint치ctico (Sugar Syntax)_ porque en JavaScript no tenemos clases, tenemos prototipos.

```javascript
class LibroTecnico extends Libro {
  constructor(tematica, paginas) {
    super(tematica, paginas);
    this.capitulos = [];
    this.precio = "";
    // ...
  }
  metodo() {
    // ...
  }
}
```

### This

La variable `this` muchas veces se vuelve un dolor de cabeza. ant칤guamente ten칤amos que cachearlo en otra variable ya que solo hace referencia al contexto en el que nos encontremos. Por ejemplo, en el siguiente c칩digo si no hacemos `var that = this` dentro de la funci칩n `document.addEventListener`, _this_ har칤a referencia a la funci칩n que pasamos por _Callback_ y no podr칤amos llamar a `foo()`

```javascript
//ES3
var obj = {
	foo : function() {...},
    bar : function() {
    	var that = this;
        document.addEventListener("click", function(e) {
        	that.foo();
        });
    }
}
```

Con ECMAScript5 la cosa cambi칩 un poco, y gracias al m칠todo `bind` pod칤amos indicarle que `this` hace referencia a un contexto y no a otro.

```javascript
//ES5
var obj = {
	foo : function() {...},
    bar : function() {
        document.addEventListener("click", function(e) {
        	this.foo();
        }.bind(this));
    }
}
```

Ahora con ES6 y la funci칩n _Arrow_ `=>` la cosa es todav칤a m치s visual y sencilla.

```javascript
//ES6
var obj = {
	foo : function() {...},
    bar : function() {
    	document.addEventListener("click", (e) => this.foo());
    }
}
```

### `let` y `const`

Ahora podemos declarar variables con `let` en lugar de `var` si no queremos que sean accesibles m치s all치 de un 치mbito. Por ejemplo:

```javascript
//ES5
(function () {
  console.log(x); // x no est치 definida a칰n.
  if (true) {
    var x = "hola mundo";
  }
  console.log(x);
  // Imprime "hola mundo", porque "var" hace que sea global
  // a la funci칩n;
})();

//ES6
(function () {
  if (true) {
    let x = "hola mundo";
  }
  console.log(x);
  //Da error, porque "x" ha sido definida dentro del "if"
})();
```

Ahora con `const` podemos crear constantes que s칩lo se puedan leer y no modificar a lo largo del c칩digo. Veamos un ejemplo

```javascript
(function() {
	const PI;
    PI = 3.15;
    // ERROR, porque ha de asignarse un valor en la
    // declaraci칩n
})();

(function() {
	const PI = 3.15;
    PI = 3.14159;
    // ERROR de nuevo, porque es s칩lo-lectura
})();
```

### Template Strings

Con ES6 podemos interpolar _Strings_ de una forma m치s sencilla que como est치bamos haciendo hasta ahora. F칤jate en este ejemplo:

```javascript
//ES6
let nombre1 = "JavaScript";
let nombre2 = "awesome";
console.log(`S칩lo quiero decir que ${nombre1} is ${nombre2`);
// Solo quiero decir que JavaScript is awesome
```

Tambi칠n podemos tener `String` multil칤nea sin necesidad de concatenarlos con `+`.

```javascript
//ES5
var saludo = "ola " +
"que " +
"ase ";

//ES6
var saludo = "ola
que
ase";

console.log("hola
que
ase");
```

### Destructuring

Tenemos nuevas formas de asignar valores a Arrays y a Objetos. Veamos unos ejemplos

```javascript
var [a, b] = ["hola", "mundo"];
console.log(a); // "hola"
console.log(b); // "mundo"

var obj = { nombre: "Carlos", apellido: "Azaustre" };
var { nombre, apellido } = obj;
console.log(nombre); // "Carlos"
```

쯅o te ha estallado el cerebro todav칤a? Pues mira esto:

```javascript
var foo = function () {
  return ["175", "75"];
};
var [estatura, peso] = foo();
console.log(estatura); //175
console.log(peso); //75
```

### Valores por defecto

Otra novedad es asignar valores por defecto a las variables que se pasan por par치matros en las funciones. Antes ten칤amos que comprobar si la variable ya ten칤a un valor. Ahora con ES6 se la podemos asignar seg칰n creemos la funci칩n.

```javascript
//ES5
function(valor) {
	valor = valor || "foo";
}

//ES6
function(valor = "foo") {...};
```

### M칩dulos

A esto lo llamo un `browserify` nativo. Ahora JavaScript se empieza a parecer a lenguajes como _Python_ o _Ruby_. Llamamos a las funciones desde los propios Scripts, sin tener que importarlos en el HTML, si usamos JavaScript en el navegador.

```javascript
//File: lib/person.js
module "person" {
	export function hello(nombre) {
    	return nombre;
    }
}
```

> Tambi칠n se puede exportar as칤, seg칰n una aclaraci칩n de [Sergio Daniel Xalambr칤](https://twitter.com/sergiodxa)
>
> `export function hello(nombre) {...};`
> o tambi칠n, si solo es una funci칩n la que tiene el m칩dulo: `export default function(nombre) {...};`

Y para importar en otro fichero:

```javascript
//File: app.js
import { hello } from "person";
var app = {
	foo: function() {
    	hello("Carlos");
    }
}
export app;
```

## C칩mo empezar a usar ES6 hoy mismo

Todo esto es muy bonito, pero 쮺칩mo podemos empezar a utilizarlo hoy en d칤a?. Lo primero m치s recomendable es que te instales la 칰ltima versi칩n de Chrome, que es uno de los navegadores que est치 implementando las nuevas _features_ de ES6 m치s r치pidamente. Te aconsejo incluso que instales **[Chrome Canary](https://www.google.com/chrome/browser/canary.html)**, que es la versi칩n de Chrome que prueba funcionalidades antes de lanzarlas en el Chrome original.

Para probar directamente c칩digo ES6 en la consola de tu navegador. Escribe en la barra de direcciones `chrome://flags` y tendr치s una p치gina como 칠sta:

![Chrome Flags](/images/ecmascript6/chrome-flags.png)

Y activar el flag **Enable Experimental JavaScript**.

Esto te permitir치 probar algunas _features_ pero no todas porque algunas a칰n est치n en desarrollo.

La otra opci칩n, m치s extendida, es escribir en ES6 en tus ficheros JavaScript y despu칠s "compilarlos" a la versi칩n ES5. Existen herramientas como [babel](https://babeljs.io/) que te permiten lograrlo.

Por medio de [plugings y paquetes](https://babeljs.io/docs/en/plugins) podemos utilizar estas _features_ incluso las que estean en desarrollo para pr칩ximas versiones si [elegimos el paquete correspondiente](https://babeljs.io/setup).

Desde 2015, cada a침o se introducen nuevas caracter칤sticas en JavaScript. ES6 fue el cambio m치s radical y es normal encontrar referencias a esta versi칩n como ES6 o ES2015, las siguientes versiones al principio se les llamaba ES7 y ES8, pero se ha optado por indicarlas con el a침o en el que son lanzados.

Por eso, hasta el momento podemos encontrar ES2015, ES2016, ES2017 y el m치s reciente ES2018, aunque como digo, desde la versi칩n de 2015 los cambios son menores.

![ES6 next stop](/images/ecmascript6/autopista-hacia-es6.png)

> **쯈uieres aprender JavaScript desde cero hasta el nuevo est치ndar de ECMAScript 6?** Hazlo con mi ebook [_Aprendiendo JavaScript_](https://leanpub.com/aprendiendo-javascript) que ya tienen **m치s de 500 lectores**. Cons칤guelo [aqu칤](https://leanpub.com/aprendiendo-javascript)

---
title: "Formas de manejar la asincron칤a en JavaScript"
date: "2016-06-23"
tags:
  - "游눹 Desarrollo"
---

Si hay algo que caracteriza a JavaScript, es la asincron칤a que presentan algunas funciones. Concretamente las que realizan operaciones de entrada/salida como escritura o lectura del disco o una petici칩n AJAX.

En JavaScript existen varias formas de manejar estos procesos en nuestros desarrollos.
Veamos cuales son.

<YouTube videoId="kJ389bfH7iE" />

## Callbacks

Es la primera y la forma m치s com칰n de controlar la asincron칤a en JavaScript.

En el siguiente ejemplo tenemos una funci칩n que recibe como par치metros un dato de entrada: `data`, un array con datos `array` y una funci칩n de callback: `callback`.

El funcionamiento de la funci칩n es muy simple, al `array` se le a침ade el `data` que viene por par치metro y cuando termine, llama a la funci칩n de `callback` que recibe por par치metro, en ese caso la llama con el `array` modificado.

He a침adido un peque침o bloque para comprobar si el array existe y si no lanzar un error que pasaremos al callback.

```javascript
function addToArray (data, array, callback) {
  if (!array) {
    callback(new Error('No existe el array), null)
  } else {
    array.push(data)
    callback(null, array)
  }
}
```

En el siguiente c칩digo vemos como llamara a este funci칩n y tratar el callback:

```javascript
var array = [1, 2, 3];

addToArray(4, array, function (err) {
  if (err) return console.log(err.message);
  console.log(array);
});

// [1, 2, 3, 4]
```

쮼sto que va a devolver? Cuando se termine de ejecutar la funci칩n `addToArray` se ejecutar치 el callback y nos mostrar치 el array con el nuevo dato.

Parece una tonter칤a porque podr칤amos a침adir el dato al array y despu칠s imprimirlo con `console.log`, pero imaginemos que esa operaci칩n de a침adir un item al array fuera asincr칩nica, como podr칤a ser una llamada v칤a AJAX.

Para simular esto vamos a utilizar la funci칩n `setTimeout` para a침adir un retardo de 1 segundo:

```javascript
function addToArray (data, array, callback) {
  if (!array) {
    return callback(new Error('No existe el array', null)
  }
  setTimeout(function() {
    array.push(data)
    callback(null, array)
  }, 1000)
}

var array = [1,2,3];

addToArray(4, array, function (err) {
  if (err) return console.log(err.message)
  console.log(array)
})
// (1 seg de delay)-> [1, 2, 3, 4]
```

Si no tuvi칠ramos una funci칩n de callback, y la funci칩n `addToArray` fuera:

```javascript
function addToArray(data, array) {
  setTimeout(function () {
    array.push(data);
  }, 1000);
}
```

y ejecut치ramos la funci칩n, nos devolver칤a lo siguiente:

```javascript
var array = [1, 2, 3];
addToArray(4, array);
console.log(array);

// [1, 2, 3]
```

Cuando imprimimos el array a칰n no se ha a침adido el nuevo item, por lo tanto el comportamiento que sucede no es el buscado. De esta forma los callbacks nos ayudan a lidiar con esto.

Pero si tenemos varias funciones as칤... puede ocurrir lo siguiente:

```javascript
var array = [1,2,3];

addToArray(4, array, function (err) {
  if (err) ...
  addToArray(5, array, function (err) {
    if (err) ...
    addToArray(6, array, function (err) {
      if (err) ...
      addToArray(7, array, function () {
        // Hasta el infinito y m치s all치...
      })
    })
  })
});
```

El temido **Callback Hell** o **Pyramid of Doom**

![Callback hell](/images/manejando-la-asincronia-en-javascript/callback-hell.png)

Por suerte esto se ha podido resolver utilizando librer칤as como [`async`](https://www.npmjs.com/package/async), o empleando promesas con librer칤as como [`Q`](https://www.npmjs.com/package/q).


## Promesas

<YouTube videoId="6O8ax3JYboc" />

Por suerte, en la [nueva especificaci칩n de JavaScript (ES6 o ES2015)](/ecmascript6/) **las Promesas ya son nativas** y no necesitamos requerir librer칤as de terceros.

Veamos el mismo ejemplo que antes pero utilizando Promesas nativas de ES2015

```javascript
function addToArray(data, array) {
  const promise = new Promise(function (resolve, reject) {
    setTimeout(function () {
      array.push(data);
      resolve(array);
    }, 1000);

    if (!array) {
      reject(new Error("No existe un array"));
    }
  });

  return promise;
}

const array = [1, 2, 3];
addToArray(4, array).then(function () {
  console.log(array);
});
```

Ahora la funci칩n `addToArray` crea un objeto `Promise` que recibe como par치metros una funci칩n con las funciones `resolve` y `reject`.

`resolve` la llamaremos cuando nuestra ejecuci칩n finalice correctamente.

De esta manera, podemos escribir c칩digo de manera m치s elegante, y el _Callback Hell_ anterior puede ser resuelto as칤:

```javascript
const array = [1, 2, 3];
addToArray(4, array)
  .then(function () {
    return addToArray(5, array);
  })
  .then(function () {
    return addToArray(6, array);
  })
  .then(function () {
    return addToArray(7, array);
  })
  .then(function () {
    console.log(array);
  });

// (4 seg. de delay)-> [1,2,3,4,5,6,7]
```

Esto se conoce como _anidar promesas_.

La forma de tratar errores en una promesa, es por medio de la funci칩n `catch` que recoge lo que enviamos en la funci칩n `reject` dentro de la Promesa. Y esta funci칩n solo hay que invocarla una vez, no necesitamos comprobar en cada llamada si existe error o no. Lo cual reduce mucho la cantidad de c칩digo

```javascript
const array = ''
addToArray(4, array)
  .then(...)
  .then(...)
  .then(...)
  .catch(err => console.log(err.message))

// No existe el array
```

## Async/Await

El siguiente paso en el tratamiento de los procesos as칤ncronos es usar los m칠todos `async/await`. 칄sta forma no est치 disponible en el est치ndar de ES6 o ES2015, si no que **forma parte de la pr칩xima versi칩n ES7 o ES2016**, pero que que podemos utilizar hoy d칤a [con Babel y el preset de plugins `stage-3`](http://babeljs.io/docs/plugins/preset-stage-3/)

La sintaxis para una funci칩n que utilice _async/await_ es la siguiente

```javascript
async function myFuncion () {
  try {
    var result = await functionAsincrona()
  } catch (err) {
    ...
  }
}
```

La funci칩n ir치 precedida por la palabra reservada `async` y dentro de ella tendremos un bloque `try-catch`. Dentro del `try` llamararemos a la funci칩n as칤ncrona con la palabra reservada `await` delante, con esto hacemos que la funci칩n _espere_ a que se ejecute y el resultado de la misma est치 disponible en este caso en la variable `result`.

Si ocurre alg칰n error durante la ejecuci칩n, se ejecutar치 el bloque `catch` donde trataremos el error.

Combinando `async/await` con una funci칩n basada en Promesas, podemos hacer lo siguiente con el ejemplo que est치bamos viendo:

```javascript
function addToArray(data, array) {
  const promise = new Promise(function (resolve, reject) {
    setTimeout(function () {
      array.push(data);
      resolve(array);
    }, 1000);

    if (!array) {
      reject(new Error("No existe un array"));
    }
  });

  return promise;
}

const array = [1, 2, 3];

async function processData(data, array) {
  try {
    const result = await addToArray(data, array);
    console.log(result);
  } catch (err) {
    return console.log(err.message);
  }
}

processData(4, array);
// [1,2,3,4]
processData(5, array);
// [1,2,3,4,5]
processData(6, array);
// [1,2,3,4,5,6]
```

De esta manera estamos escribiendo c칩digo de manera secuencial pero JavaScript est치 _por debajo_ ejecutando c칩digo asincr칩nico.

Esto permite que, desarrolladores que est칠n menos familiarizados con JavaScript y su comportamiento, no tengan tantas barreras de entrada para empezar a trabajar con el lenguaje.

**쯈u칠 te parece la evoluci칩n de JavaScript? 칔nete a la conversaci칩n y no dudes en aportar tus impresiones.**

Si quieres conocer m치s sobre el lenguaje, te [recomiendo mi ebook **Aprendiendo JavaScript** que ya tienen m치s de 500 lectores](http://leanpub.com/aprendiendo-javascript) :)

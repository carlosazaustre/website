---
title: "WebComponents Nativos: C√≥mo pasar propiedades"
date: "2018-08-31"
tags:
  - "üíª Desarrollo"
---

En un [post anterior vimos como crear un webcomponent de forma nativa](/como-crear-webcomponent-de-forma-nativa/), sin librer√≠as. Utilizando puro JavaScript y las APIS del navegador (**CustomElements v1** y **ShadowDOM v1**)

Este art√≠culo extiende el anterior para ver como podr√≠amos pasar propiedades a un **WebComponent**.

## A√±adiendo una propiedad al Web Component

Voy a tomar el [ejemplo anterior](/como-crear-webcomponent-de-forma-nativa/) para a√±adir una propiedad al elemento.

Antes ten√≠amos `<sell-button></sell-button>` ahora quiero a√±adir el texto del bot√≥n como propiedad tal que as√≠: `<sell-button text="Lo quiero!"></sell-button>`

As√≠ que tomando el c√≥digo de `sell-button.html` que ten√≠amos:

```javascript
class SellButton extends HTMLElement {
  constructor() {
    super();
    this.importDocument = document.currentScript.ownerDocument;
  }

  connectedCallback() {
    let shadowRoot = this.attachShadow({ mode: "open" });
    const t = this.importDocument.querySelector("#sellBtn");
    const instance = t.content.cloneNode(true);
    shadowRoot.appendChild(instance);
  }
}

window.customElements.define("sell-button", SellButton);
```

Vamos a realizar algunos cambios para que acepte propiedades. Modificamos un poco el `<template>` eliminando el texto del `button` y colocando un tag `slot` que nos permite a√±adir texto desde el exterior:

```markup
<div class="btn-container">
  <button class="btn"><slot></slot></button>
</div>
```

Los elementos pueden reaccionar ante cambios en sus atributos, si estos han sido definidos en otra de las funciones del ciclo de vida de un `customElement` en concreto en la funci√≥n `attributeChangedCallback` que recibe como par√°metros el nombre del atributo o propiedad, el valor que ten√≠a anteriormente y el nuevo valor.

Aqui lo que vamos a hacer es cambiar el contenido textual del componente (gracias al tag `<slot>` que hemos a√±adido al `template`) por el nuevo valor

### Observando cambios

```javascript
attributeChangedCallback(name, oldValue, newValue) {
  this.textContent = newValue;
}
```

√âste m√©todo s√≥lo se disparar√° si hemos declarado el atributo o propiedad `attrName` en la funci√≥n `observedAttributes` de la clase del elemento.

```javascript
static get observedAttributes () {
   return ['text'];
}
```

Es una funci√≥n `get` de ECMAScript6, lo que significa que va a ser invocada autom√°ticamente, en este caso cuando se dispare `attributeChangedCallback` y se ejecutar√° por cada uno de los atributos que tengamos en el array que devuelve la funci√≥n. En este caso solo el atributo `text`.

Resumiendo, el contenido actualizado del **Web Component** `sell-button` ser√° el siguiente:

```javascript
<html>
  <template id="sellBtn">
    <style>
      :host {
        --orange: #e67e22;
        --space: 1.5em;
      }
      .btn-container {
        border: 2px dashed var(--orange);
        padding: var(--space);
        text-align: center;
      }
      .btn {
        background-color: var(--orange);
        border: 0;
        border-radius: 5px;
        color: white;
        padding: var(--space);
        text-transform: uppercase;
      }
    </style>

    <div class="btn-container">
     <button class="btn"><slot></slot></button>
   </div>
  </template>

  <script>
    class SellButton extends HTMLElement {
      constructor() {
        super();
        this.importDocument = document.currentScript.ownerDocument;
      }

      static get observedAttributes () {
        return ['text'];
      }

      attributeChangedCallback (name, oldValue, newValue) {
        this.textContent = newValue;
      }

      connectedCallback () {
        let shadowRoot = this.attachShadow({mode: 'open'});
        const t = this.importDocument.querySelector('#sellBtn');
        const instance = t.content.cloneNode(true);

        shadowRoot.appendChild(instance);
      }

    }

    customElements.define('sell-button', SellButton);
  </script>

</html>

```

Y para verificar que si se cambia el atributo, se refleja en el interior del `template` del componente, vamos a crear una funci√≥n de `setTimeout` que pasados 3 segundos, modifique el valor de la propiedad `text`:

```javascript
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>WebComponents</title>
    <link rel="import" href="components/sell-button.html">
  </head>
  <body>
    <sell-button text="Comprar Ahora"></sell-button>

    <script type="text/javascript">
      setTimeout(() => {
        let anotherEl = document.querySelector('sell-button');
        anotherEl.setAttribute('text', 'Lo quiero ahora!');
      }, 3000);
    </script>
  </body>
</html>
```

De esta forma, al cargar la p√°gina tendremos esto:
![](/images/webcomponents-nativos-como-pasar-propiedades/Screen-Shot-2017-03-22-at-13.15.40.png)

Y despu√©s, tras cambiar el valor de `text` por el texto: "Lo quiero ahora!" tendr√≠amos esto:

![](/images/webcomponents-nativos-como-pasar-propiedades/Screen-Shot-2017-03-22-at-13.15.44.png)

Puedes ver esto en funcionamiento en el siguiente **[CodePen](https://codepen.io/carlosazaustre/project/editor/ArjknA/)**

> **RECUERDA**:

> Prueba este ejemplo en una versi√≥n reciente de Chrome o en su defecto en Chrome Canary, ya que los `HTMLImports` no est√°n soportados en Safari, Firefox ni Edge. Para eso necesitas usar el Polyfill de `webcomponents`

## A√±adiendo m√°s de una propiedad

¬øY qu√© pasa si queremos utilizar m√°s de una propiedad?
En ese caso hay que hacer algo m√°s de "fontaner√≠a". Imaginemos que ahora nuestro _custom-element_ queremos que tenga √©sta pinta y que ademas sus propiedades sean _observables_:

```html
<sell-button intro="Oferta" text="Comprar Ahora"></sell-button>
```

Bien, primero vamos a modificar el `<template>` ya que ahora con un √∫nico elemento `<slot>` no nos sirve, ya que tendremos dos propiedades. Vamos a a√±adir otro y los vamos a distinguir por la propiedad `name`:

```html
<div class="btn-container">
  <h1><slot name="intro"></slot></h1>
  <button class="btn"><slot name="text"></slot></button>
</div>
```

Despu√©s a√±adimos la nueva propiedad `intro` a la funci√≥n `observedAttributtes`:

```javascript
static get observedAttributes () {
  return ['intro', 'text'];
}
```

Tambi√©n vamos a actualizar el constructor, a√±adiendo un par de variables "privadas" que guarden el valor de estos atributos para uso interno:

```javascript
constructor() {
  super();
  this._text = null;
  this._intro = null;
  this.importDocument = document.currentScript.ownerDocument;
}
```

Despu√©s vamos a implementar dos funciones _getter_ y _setter_ de ECMAScript 6 que se invocar√°n cada vez que vayamos a acceder a la propiedad en cuesti√≥n. Es decir, si queremos acceder a `this.intro` o cambiar el valor de `this.intro`, se llamar√° autom√°ticamente a la funci√≥n `get intro()` en el primer caso y a la funci√≥n `set intro(val)` en el segundo:

```javascript
get text () {
  return this.getAttribute('text');
}
set text (val) {
  this._text = val;
}

get intro () {
  return this.getAttribute('intro');
}
set intro (val) {
  this._intro = val;
}
```

Lo √∫nico que hacemos aqu√≠ es que cuando queramos leer el valor de `text` o `intro` devolvemos el valor que tiene el atributo con `this.getAttribute`. Y cuando lo queramos modificar le pasamos el valor a la variable "privada" que habiamos declarado en el constructor.

Despu√©s modificamos la funci√≥n `attributeChangedCallback` para que ante los cambios (si se producen) sea capaz de reflejarlos en el ShadowDOM:

```javascript
attributeChangedCallback (name, oldValue, newValue) {
  if (this.shadowRoot) {

  this.shadowRoot.querySelector(`[name="${name}"]`).innerHTML = this[name];
  }
}
```

Como `name` cambia seg√∫n los atributos que se devuelven en el array de `observedAttributes`, `name` ser√° `text` o `intro` seg√∫n lo que se actualice.

Aqu√≠ hacemos una comprobaci√≥n si existe el `shadowRoot` ya que en un primer momento, cuando declaramos el componente con propiedades, este m√©todo se invoca pero el ShadowDOM no est√° listo, entonces hay que hacer esta peque√±a comprobaci√≥n, para cuando lo est√© poder hacer una llamada a `querySelector` buscar el `<slot>` con el nombre que hayamos definidos y pasarle el valor de `this.intro` o `this.text` seg√∫n el atributo que se haya cambiado.

Y por √∫ltimo, actualizamos el m√©todo `connectedCallback` para que a√±ada los valores de las propiedades al ShadowDOM en su creaci√≥n:

```javascript
connectedCallback () {
  let shadowRoot = this.attachShadow({mode: 'open'});
  const t = this.importDocument.querySelector('#sellBtn');
  const instance = t.content.cloneNode(true);

  instance.querySelector('[name="text"]').innerHTML = this.text;
  instance.querySelector('[name="intro"]').innerHTML = this.intro;

  shadowRoot.appendChild(instance);
}
```

Resumiendo, el componente completo ser√≠a as√≠:

```javascript
<html>
  <template id="sellBtn">
    <style>
      :host {
        --orange: #e67e22;
        --space: 1.5em;
      }
      .btn-container {
        border: 2px dashed var(--orange);
        padding: var(--space);
        text-align: center;
      }
      .btn {
        background-color: var(--orange);
        border: 0;
        border-radius: 5px;
        color: white;
        padding: var(--space);
        text-transform: uppercase;
      }
    </style>

    <div class="btn-container">
      <h1><slot name="intro"></slot></h1>
     <button class="btn"><slot name="text"></slot></button>
   </div>
  </template>

  <script>
    'use strict';

    class SellButton extends HTMLElement {
      constructor() {
        super();
        this._text = null;
        this._intro = null;
        this.importDocument = document.currentScript.ownerDocument;
      }

      static get observedAttributes () {
        return ['intro', 'text'];
      }

      attributeChangedCallback (name, oldValue, newValue) {
        if (this.shadowRoot) {
          this.shadowRoot.querySelector(`[name="${name}"]`).innerHTML = this[name];
        }
      }

      connectedCallback () {
        let shadowRoot = this.attachShadow({mode: 'open'});
        const t = this.importDocument.querySelector('#sellBtn');
        const instance = t.content.cloneNode(true);

        instance.querySelector('[name="text"]').innerHTML = this.text;
        instance.querySelector('[name="intro"]').innerHTML = this.intro;

        shadowRoot.appendChild(instance);
      }

      get text () {
        console.log('get text()')
        return this.getAttribute('text');
      }
      set text (val) {
        console.log(`set text(${val})`);
        this._text = val;
      }

      get intro () {
        console.log('get intro()');
        return this.getAttribute('intro');
      }
      set intro (val) {
        console.log(`set intro(${val})`);
        this._intro = val;
      }
    }

    customElements.define('sell-button', SellButton);
  </script>

</html>
```

Si en nuestro `index.html` modificamos el componente con el nuevo atributo, tendr√≠amos este resultado:

```markup
<sell-button intro="Oferta" text="Comprar Ahora"></sell-button>
```

![](/images/webcomponents-nativos-como-pasar-propiedades/Screen-Shot-2017-03-22-at-17.41.05.png)

Y si hacemos como con el ejemplo anterior, una funci√≥n de _timeout_ que cambie las propiedades pasados 2 segundos, tendremos el nuevo resultado:

![](/images/webcomponents-nativos-como-pasar-propiedades/Screen-Shot-2017-03-23-at-09.18.08.png)

En el mismo [CodePen](https://codepen.io/carlosazaustre/project/editor/ArjknA/) tienes el c√≥digo y demo de este ejemplo (En este caso en el archivo `sell-button-copy.html`.

## Conclusi√≥n

Con esto hemos visto como funciona el est√°ndar de _Web Components_ de la W3C. Usando las APIs nativas que provee el navegador. Como has podido ver, hay bastante c√≥digo que puede ser algo repetitivo si por ejemplo tenemos varias propiedades a observar.

Este tipo de cosas son las que implementan librer√≠as como [Polymer](https://www.polymer-project.org/) que sobre todo en su versi√≥n 2.0 han eliminado muchas cosas para dar mayor protagonismo al soporte nativo del navegador.

---

## Referencias

Si quieres profundizar m√°s sobre √©sta nueva tecnolog√≠a te dejo los siguientes enlaces:

- [Especificaci√≥n de la W3C sobre CustomElements](https://www.w3.org/TR/custom-elements/)
- [_Observing Changes to Attributes_: Custom Elements v1 Reusable Web Components por Google Developers](https://developers.google.com/web/fundamentals/getting-started/primers/customelements#upgrades)
- [Custom Elements, by Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements)

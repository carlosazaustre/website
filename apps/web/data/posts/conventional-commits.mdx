---
title: "Conventional Commits - Especificaci√≥n para tus mensajes de commit"
date: "2022-11-29"
tags:
  - "üßëüèª‚Äçüíª Desarrollo"
  - "üì¶ Git"
---

## ¬øQu√© son los mensajes de commit?

Los mensajes de commit son una forma de documentar los cambios que se realizan en un repositorio de c√≥digo.
Estos mensajes son muy √∫tiles para entender qu√© cambios se realizaron en un proyecto, y por qu√© se hicieron.

Cuando se trabaja en un equipo de desarrollo, es muy importante que todos los miembros del equipo
puedan entender qu√© cambios se realizaron en el c√≥digo, y por qu√© se realizaron.

## Conventional Commits

<YouTube videoId="SigVVJmUGv8" />

Como dice su [p√°gina oficial](https://www.conventionalcommits.org/es/v1.0.0/): Es una especificaci√≥n
para dar significado a los mensajes de commits haci√©ndolos comprensibles tanto para las m√°quinas como
para las personas. Proporciona un conjunto sencillo de reglas para crear un historial de commits expl√≠cito;
lo que hace m√°s f√°cil poder escribir herramientas automatizadas. Esta convenci√≥n encaja con [SemVer](http://semver.org/),
ya que podemos explicar en los mensajes de commits, si es una _feature_, _bugfix_, incluso si hay "Breaking Changes\*.

Si no conoc√≠as el t√©rmino de **Semantic Versioning**, en este v√≠deo corto te lo cuento:

<YouTube videoId="k_nV7ExQdw4" />

La estructura de un mensaje de commit siguiendo la especificaci√≥n ser√≠a la siguiente:

```shell
<tipo>[scope opcional]: <descripci√≥n del commit>

[cuerpo del mensaje, opcional]

[footer(s), opcionales]

```

### Tipos de commits

Los tipos de commits son los siguientes:

- **feat**: Una nueva caracter√≠stica o funcionalidad. Tendr√≠a correlaci√≥n con una versi√≥n MINOR siguiendo _SemVer_.
- **fix**: Un error corregido. Tendr√≠a correlaci√≥n con una versi√≥n PATCH siguiendo _SemVer_.
- **BREAKING CHANGE**: Un cambio que contenga esta palabra en el `footer` del mensaje o un signo `!` despues del tipo o scope,
  rompe la compatibilidad con versiones anteriores. Tendr√≠a correlaci√≥n con una versi√≥n MAJOR siguiendo _SemVer_.

Se permiten tambi√©n los siguientes tipos:

- **build**: Cambios que afectan el sistema de compilaci√≥n o dependencias externas (ej. cambios en el `package.json`).
- **ci**: Cambios en nuestros archivos y scripts de configuraci√≥n de integraci√≥n continua.
- **docs**: Cambios en la documentaci√≥n.
- **chore**: Otros cambios que no afectan el c√≥digo fuente.
- **perf**: Un cambio de c√≥digo que mejora el rendimiento.
- **refactor**: Un cambio de c√≥digo que no corrige un error ni agrega una caracter√≠stica.
- **style**: Cambios que no afectan el significado del c√≥digo (espacios en blanco, formato, puntos y comas faltantes, etc).
- **test**: Agregar pruebas faltantes o corregir pruebas existentes.

### Scope

El scope es opcional, y sirve para especificar el alcance del commit. Por ejemplo, si estamos trabajando
en un proyecto monorepo, podemos especificar el paquete que estamos modificando.

### Ejemplos

Veamos algunos ejemplos de mensajes de commit siguiento la especificaci√≥n:

**Commit que a√±ade una nueva caracter√≠stica, sin un scope en concreto**.

```shell
feat: add support for TypeScript
```

**Commit que arregla un bug, dentro del paquete `ui` de nuestro proyecto**.

```shell
fix(ui): bugfix on Button component
```

**Commit que rompe la compatibilidad con versiones anteriores, aunque no a√±ade caracter√≠sticas nuevas ni corrige bugs**.

```shell
chore!: drop support for Node 6

BREAKING CHANGE: use JavaScript features not available in Node 6.
```

**Commit que agrega pruebas faltantes**

```shell
test(ui): add missing tests for Button component
```

**Commit que agrega una tarea para el sistema de integraci√≥n/despliegue continuo**.

```shell
ci: add GitHub Actions workflow
```

**Commit con un mensaje descriptivo largo y varios footers o pie de p√°gina**.

```shell
fix(api): prevent duplicate users from being created

This commit fixes a bug where the API would allow duplicate users to be created
with the same email address. This commit also adds a new `unique` constraint to
the `users` table to prevent this from happening in the future.

Paired with: X
Fixes #123

```

## ¬øPor qu√© usar Conventional Commits?

- Permite la generaci√≥n autom√°tica del fichero CHANGELOG.
- Determina autom√°ticamente los cambios de versi√≥n siguiendo SemVer (basado en los tipos de commits utilizados).
- Comunican la naturaleza de los cambios a los dem√°s integrantes del equipo o cualquier persona interesada.
- Activa los procesos de build y despliegue o publicaci√≥n.
- Hacer m√°s f√°cil a otras personas contribuir al proyecto al permitirles explorar el historial de commits de una forma m√°s estructurada.

## Herramientas para usar Conventional Commits

### Plugin de VSCode

La primera que utilizo es la extensi√≥n o plugin de VSCode, [Conventional Commit](https://marketplace.visualstudio.com/items?itemName=vivaxy.vscode-conventional-commits). Me ayuda a elegir el tipo de commit,
el scope, escribir el mensaje,... todo a base de ventanas de dialogo.

### Gitemoji

Para darle m√°s colorido a nuestros commits, podemos usar la convenci√≥n [Gitemoji](https://gitmoji.dev/). Es una convenci√≥n en la que
los emojis representan el tipo de commit. Por ejemplo, el emoji üêõ representa un bugfix, ‚ú® un nuevo feature, etc... As√≠ de un vistazo
r√°pido puedes ver que tipo de cambio se ha realizado.

### Commitlint

[Commitlint](https://commitlint.js.org/#/) es una herramienta que nos permite configurar reglas para validar los mensajes de commit.
Igual que usamos un linter para comprobar si seguimos ciertas reglas de estilo en nuestro c√≥digo, lo podemos usar para
los mensajes de commit.

Para ello necesitas instalar la librer√≠a `@commitlint/cli` y `@commitlint/config-conventional` en tu proyecto.

```shell
npm install --save-dev @commitlint/cli @commitlint/config-conventional
```

Una vez instaladas, debes crear un fichero de configuraci√≥n llamado `commitlint.config.js` en la ra√≠z
de tu proyecto con el siguiente contenido:

```js
module.exports = {
  extends: ["@commitlint/config-conventional"],
};
```

### Husky

Ya vimos [para que serv√≠a Husky en un post anterior](/husky-lintstaged). Ahora vamos a a√±adirle una nueva regla al hook `pre-commit` para
que verifique y valide si el mensaje de commit cumple las reglas de la convenci√≥n Conventional Commits.

Si ya tienes [configurado Husky](/husky-lintstaged) lo √∫nico que has de hacer es ejecutar el siguiente comando
en la ra√≠z de tu proyecto para que a√±ada el comando al hook `commit-msg`:

```shell
npx husky add .husky/commit-msg  'npx --no -- commitlint --edit ${1}'
```

Y listo, cada vez que hagas un commit, verificar√° que sigue las reglas.

### CHANGELOG

Por √∫ltimo, tambi√©n es interesante poder generar autom√°ticamente el fichero CHANGELOG a partir de los mensajes de commit.
Para ello hay diversas herramientas, una de ellas es [Conventional Changelog](https://github.com/conventional-changelog/conventional-changelog)

---
title: "Desarrollo por componentes con Angular 1.5 y ES6/ES2015"
date: "2016-07-04"
tags:
  - "üíª Desarrollo"
---

En el pasado [AngularCamp](http://angularcamp.org) impart√≠ un workshop ense√±ando una aplicaci√≥n web de ejemplo empleando la √∫ltima versi√≥n de Angular 1x, la 1.5.6 que introduce el m√©todo `.component()` para desarrollar basado en componentes (Como har√≠a _React_ o _Angular2_) y empleando para ello ECMAScript6 (o ES2015), para que nuestro c√≥digo con Angular 1x cada vez se parezca m√°s a Angular2.

En el ejemplo uso **UIRouter** para las rutas, en su √∫ltima versi√≥n _alpha_ a d√≠a de hoy. Emplear√© Babel para traducir ES6 a ES5. No usar√© TypeScript.

La aplicaci√≥n es una lista de los speakers de la pasada AngularCamp y cada speaker tiene su vista detalle.

Sin nada m√°s, vamos manos a la obra!

## Arquitectura de Componentes

Con Angular 1.5 podemos dividir nuestra aplicaci√≥n en componentes, haciendo uso del m√©todo `.component()`. [Antes pod√≠amos hacerlo por directivas ](/angular-js-directivas-como-componentes/) pero de esta forma el c√≥digo est√° mejor adaptado y nos prepara para el salto a Angular2, sobre todo si empleamos el nuevo est√°ndar de JavaScript para ello y la excelente [gu√≠a de estilo de Todd Motto](https://github.com/toddmotto/angular-styleguide).

La aplicaci√≥n de ejemplo tendr√° los siguientes componentes:

![Arquitectura de componentes en una web app Angular 1.5](/images/desarrollo-por-componentes-con-angular-1-5-con-es6-es2015/app_angular_components.png)

- `AppComponent` ser√° el componente ra√≠z donde reside toda la l√≥gica de la aplicaci√≥n.

- `HeaderComponent` y `FooterComponent` son componentes comunes que podemos reutilizar en otras aplicaciones.

- `SpeakerList`: Representa la vista principal compuesta por una lista de `SpeakerItems`.

- `SpeakerItem`: Cada uno de los Speakers representados en la lista.

- `SpeakerDetail`: Vista en detalle de cada speaker, accesible bajo una URL determinada.

## Iniciando el proyecto

Primero de todo creamos un proyecto con NPM en una carpeta e instalamos las **dependencias** que utilizaremos v√≠a NPM

```shell
$ npm init -y
$ npm i -S angular angular-ui-router@1.0.0-alpha.5
```

Las siguientes **dependencias** no son de Angular, si no de la **parte Backend** desde la que voy a servir el API. Tambi√©n las instalamos con NPM a trav√©s de la terminal.

```shell
$ npm i -S express body-parser
```

Y por √∫ltimo las siguientes **dependencias para desarrollo** que nos servir√°n para usar babel en conjunto con browserify y el conjunto de plugins para que entienda ES2015.

```shell
$ npm i -S babel-runtime babel-preset-es2015 browserify watchify nodemon parallelshell
```

A continuaci√≥n vamos a escribir una serie de **NPM scripts** en el fichero `package.json` para ayudarnos con la ejecuci√≥n de ciertas tareas:

```js
"scripts": {
    "create": "touch ./server/public/app.js",
    "build": "browserify -t babelify -t uglifyify ./app/app.js -o ./server/public/app.js",
    "watch": "watchify -t babelify ./app/app.js -o ./server/public/app.js --debug",
    "postinstall": "npm run create && npm run build",
    "dev": "nodemon ./server/index.js",
    "serve": "parallelshell 'npm run dev' 'npm run watch'"
  },
```

- `npm run create`: Genera un fichero `app.js` vac√≠o donde estar√° la versi√≥n transpilada y empaquetizada de nuestra app.

- `npm run build`: Genera el fichero final resultante de todos los ficheros JS de nuestra app. Le aplicamos la transformaci√≥n **babelify** que nos permite utilizar babel en conjunto con **Browserify**, de esta manera en lugar de usar `require` para importar los m√≥dulos, podemos usar la forma de ES6/ES2015.

- `npm run watch`: Ejecuta el mismo comando que `build` pero empleando **Watchify**. Que es como Browserify, pero en lugar de crear el bundle de nuevo de todo el proyecto, solo se preocupa de los cambios, lo que nos permite crear bundles m√°s r√°pidos para desarrollo.
  `postinstall`: Este comando se ejecutar√° despu√©s de realizar `npm install` y genera el fichero build final.

- `npm run dev`: ejecuta el servidor Node/Express b√°sico que ahora implementaremos, de manera que se reinicie a cada cambio que hagamos.

- `npm run serve`: Gracias a **parallelshell** podemos ejecutar en paralelo varios comandos, en este caso el servidor de desarrollo con `npm run dev` y el `watch` de los cambios de la parte frontend.

Y por √∫ltimo, s√≥lo nos queda que Babel ejecute los plugins que queremos, para ello creamos un fichero `.babelrc` en el directorio ra√≠z del proyecto con el siguiente contenido:

```js
{
  "presets": ["es2015"]
}
```

De esta manera le indicamos que utilice el **preset de plugins de ES2015/ES6**.

## Servidor Node/Express.

Creamos un servidor web muy sencillo con **Node.js y Express** que tendr√° una parte de ficheros est√°ticos donde estar√° el `index.html` de nuestra SPA y el fichero `.js` que genera Browserify.

Tambi√©n tendr√° 3 rutas, 2 de ellas de nuestro _pseudo-API_ y una para servir el index.html. Aqu√≠ va el c√≥digo:

```js
// server/index.js
"use strict";

const express = require("express");
const bodyParser = require("body-parser");
const path = require("path");

const app = express();

/** Express configuration */
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());
app.use(express.static(path.join(__dirname, "public")));

/** API routes */
// Muestra todos los speakers.
app.get("/api/speakers", (req, res) => {
  res.sendFile(path.join(__dirname, "db", "speakers.json"));
});

// Muestra info de un √∫nico speaker.
app.get("/api/speakers/:id", (req, res) => {
  res.sendFile(path.join(__dirname, "db", `${req.params.id}.json`));
});

// env√≠a el index.html para la SPA.
app.get("*", (req, res, next) => {
  if (req.accepts("html")) {
    res.sendFile(path.join(__dirname, "public", "index.html"));
  } else {
    next();
  }
});

/** Inicia el servidor */
app.listen(3000, () => console.log("Express running on port 3000"));
```

En `server/db/` tengo varios ficheros `.json` que simulan una base de datos. Todo este c√≥digo lo tienes en el [repositorio de √©ste proyecto]().

Y en `server/public/index.html` este es el documento:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AngularCamp</title>
  </head>
  <body>
    <ac-app></ac-app>
    <script type="text/javascript" src="app.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.6/css/materialize.min.css"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
  </body>
</html>
```

Donde `<ac-app></ac-app>` es nuestro componente ra√≠z donde se encuentra toda la l√≥gica de nuestra SPA AngularjS.

## Componente Ra√≠z.

El componente principal de nuestra aplicaci√≥n, o componente ra√≠z ser√° el **AppComponent** y su representaci√≥n en html ser√° `<ac-app></ac-app>`. Donde `ac` significar√≠a AngularCamp.

La nueva funci√≥n `component()` de Angular 1.5 sigue la siguiente sintaxis:

```js
angular.component("nombreComponente", {
  bindings: {},
  controller: function MiControlador() {},
  template: `<html></html>`,
});
```

- `bindings`: Sustitiuye a `scope` y `bindToController` del m√©todo `.directive()`

- `controller`: define el controlador del componente si lo tiene, esto es igual que en `.directive`.

- `template`: Lo mismo, puedes usar `templateUrl` si quieres usar un fichero `.html` para definir la plantilla o simplemente `template` para escribirla directamente.

Si quieres ampliar la informaci√≥n, [Todd Motto tiene un art√≠culo](https://toddmotto.com/exploring-the-angular-1-5-component-method/) d√≥nde explica los cambios con respecto al m√©todo `.directive()`

Por tanto, nuestro **AppComponent** lo vamos a tener en el fichero `/app/app.component.js` y despu√©s lo importaremos v√≠a m√≥dulos de ES6/ES2015

```js
// /app/app.component.js
export const AppComponent = {
  template: `
    <ac-header></ac-header>
    <div ui-view></div>
    <ac-footer></ac-footer>
  `,
};
```

Simplemente es un template con un `div` que contiene el `ui-view` donde se insertar√°n las vistas y un par de componentes comunes que representan la cabecera y el footer: `<ac-header>` y `<ac-footer>`.

Este objeto lo importamos en `app.js` donde definimos el inicio de nuestra aplicaci√≥n AngularJS:

```js
// /app/app.js
import angular from "angular";
import uiRouter from "angular-ui-router";

import common from "./common/common";
import components from "./components/components";
import { AppComponent } from "./app.component";

const root = angular
  .module("angularCamp", [uiRouter, common, components])
  .component("acApp", AppComponent);

document.addEventListener("DOMContentLoaded", () =>
  angular.bootstrap(document, ["angularCamp"])
);

export default root;
```

importamos `angular` y `angular-ui-router` adem√°s de unos m√≥dulos que ahora crearemos: `common` y `components` y el fichero que acabamos de crear `app.component.js`.

Iniciamos la aplicaci√≥n por medio de `bootstrap` (No confundir con el framework de CSS) y listo.

## Componentes Common

Siguiendo la [gu√≠a de estilo de Todd Motto](https://github.com/toddmotto/angular-styleguide#common-module) es una buena pr√°ctica separar los componentes que podr√≠an ser reutilizables de los componentes propios de la aplicaci√≥n. Por tanto en `commons` vamos a tener el header y el footer, que siguen una estructura similar al _AppComponent_:

```js
// /app/common/footer/footer.component.js
export const FooterComponent = {
  template: `
    <footer class="page-footer blue-grey darken-2">
      <div class="footer-copyright blue-grey darken-1">
        <div class="container">
          ¬© 2016 Carlos Azaustre.
        </div>
      </div>
    </footer>
  `,
};
```

```js
// /app/common/header/header.component.js
export const HeaderComponent = {
  template: `
    <nav>
      <div class="nav-wrapper red darken-4">
        <a href="#" class="brand-logo center">AngularCamp 2016</a>
      </div>
    </nav>
  `,
};
```

```js
// /app/common/common.js
import angular from "angular";

import { HeaderComponent } from "./header/header.component";
import { FooterComponent } from "./footer/footer.component";

const common = angular
  .module("app.common", [])
  .component("acHeader", HeaderComponent)
  .component("acFooter", FooterComponent).name;

export default common;
```

> Al crear el m√≥dulo, usamos la funci√≥n `.name` Esto nos permite que al exportar el fichero via ES6, se exporte el nombre del m√≥dulo y as√≠ cuando se inyecta en un `angular.module` no de problemas

## SpeakerService

A continuaci√≥n vamos a crear un servicio que se encargar√° de realizar las peticiones al API. Con ES6 vamos a implementarlo como una clase.

En el constructor inyectaremos la dependencia de la directiva `$http` y tendremos dos m√©todos o funciones: `getSpeakers` que devuelve todos y `getSpeaker(id)` que devuelve uno s√≥lo:

```js
// /app/components/speaker/speaker.service.js
class SpeakerService {
  constructor($http) {
    this.$http = $http;
  }

  getSpeakers() {
    return this.$http.get("/api/speakers").then((response) => response.data);
  }

  getSpeaker(id) {
    return this.$http
      .get(`/api/speakers/${id}`)
      .then((response) => response.data);
  }
}

SpeakerService.$inject = ["$http"];

export default SpeakerService;
```

## SpeakerList Component

El primer componente espec√≠fico de nuestra aplicaci√≥n ser√° el **SpeakerList** cuya funci√≥n ser√° representar en forma de lista los speakers que recibe del API. Veamos como:

```js
// /app/components/speaker/speaker-list/speaker-list.component.js
import controller from "./speaker-list.controller";

export const SpeakerListComponent = {
  bindings: {
    speakers: "<",
  },
  controller,
  template: `
    <ul class="collection">
      <speaker-item ng-repeat="speaker in $ctrl.speakers" data="speaker">
      </speaker-item>
    </ul>
  `,
};
```

Importamos el controlador que ahora veremos y nos aprovechamos de la forma abreviada de asignaci√≥n de propiedades de ES6.

En `bindings` tendremos el objeto `speakers` que utilizaremos en el controlador que contiene el array de speakers, y con la notaci√≥n `<` le indicamos que utilice _one-way data binding_.

Por √∫ltimo el `template` no es m√°s que una lista donde por medio de la directiva `ng-repeat` repetimos un nuevo componente `<speaker-item>` por cada `speaker` que haya en `$ctrl.speakers` (Siendo `$ctrl` el alias de nuestro controlador) y le pasamos el objeto a la propiedad `data` del nuevo componente.

Para el **controlador** tendremos el siguiente fichero, que definimos como una clase de ES6:

```js
// /app/components/speaker/speaker-list/speaker-list.controller.js
class SpeakerListController {
  constructor(SpeakerService) {
    this.speakerService = SpeakerService;
    this.speakers = [];
    this.loadData;
  }

  loadData() {
    this.speakerService.getSpeakers();
    then((response) => {
      this.speakers = response.data;
    });
  }
}

SpeakerListController.$inject = ["SpeakerService"];

export default SpeakerListController;
```

## SpeakerItem Component

Este componente representa cada uno de los speakers en la lista. Tiene una propiedad `data` por donde recibe el objeto con la info del speaker que le env√≠a el componente padre, _SpeakerList_. Este es su c√≥digo:

```js
// /app/components/speaker/speaker-item/speaker-item.component.js
import controller from "./speaker-item.controller";

export const SpeakerItemComponent = {
  bindings: {
    data: "<",
  },
  template: `
    <li class="collection-item avatar" style="border-bottom: 1px solid #cccccc;">
      <img class="circle" width="96px" ng-src="{{$ctrl.data.photo}}" alt="{{$ctrl.data.name}}" />
      <span class="title">{{$ctrl.data.name}}</span>
      <p><a ng-href="#/speakers/{{$ctrl.data.id}}">{{$ctrl.data.talk}}</a></p>
    </li>
  `,
};
```

En este caso no nos hace falta controlador, ya que los datos le llegan del componente padre a trav√©s del _binding_ de `data`. Es lo que se conoce como un componente sin estado (_stateless_) ya que solo representa informaci√≥n sin realizar ninguna llamada externa para obtener datos.

## SpeakerDetail Component

El siguiente y √∫ltimo componente que tendremos para esta sencilla app, ser√° el que representan la vista detalle del speaker.

```js
// /app/components/speaker/speaker-detail/speaker-detail.component.js

export const SpeakerDetailComponent = {
  bindings: {
    speaker: "<",
  },
  template: `
    <article class="card">
      <figure class="card-image">
        <img width="250px" src="{{$ctrl.speaker.photo}}" alt="{{$ctrl.speaker.name}}" />
        <span ng-click="$ctrl.onClick();" class="card-title">{{$ctrl.speaker.name}}</span>
      </figure>
      <section class="card-content">
        <h5>{{$ctrl.speaker.talk}}</h5>
        <p>{{$ctrl.speaker.description}}</p>
      </section>
      <aside class="card-action">
        <a href="#">{{$ctrl.speaker.complexity}}</a>
      </aside>
    </article>
  `,
};
```

En el objeto `speaker` de los `bindings` estar√° la informaci√≥n del speaker, y en lugar de realizar la llamada al servicio desde el controlador para obtener los datos, lo vamos a hacer desde la configuraci√≥n de las rutas.

De esta manera nuestro controller es m√°s ligero y en el caso de que ese sea el √∫nico cometido, nos ahorramos tener un controlador.

Lo vemos en el siguiente fichero

## M√≥dulo Speaker.

Vamos a crear un m√≥dulo que defina todos los componentes vistos: `speaker-list`, `speaker-item` y `speaker-detail` adem√°s enlazaremos el servicio `speaker-service` y realizaremos la configuraci√≥n de rutas:

```js
// /app/components/speaker/index.js
import angular from "angular";

import { SpeakerItemComponent } from "./speaker-item/speaker-item.component";
import { SpeakerListComponent } from "./speaker-list/speaker-list.component";
import { SpeakerDetailComponent } from "./speaker-detail/speaker-detail.component";
import SpeakerService from "./speaker.service";

const speaker = angular
  .module("speakers", [])
  .service("SpeakerService", SpeakerService)
  .component("speakerItem", SpeakerItemComponent)
  .component("speakerList", SpeakerListComponent)
  .component("speakerDetail", SpeakerDetailComponent)
  .config(($stateProvider, $urlRouterProvider) => {
    $stateProvider
      .state("speakers", {
        url: "/",
        component: "speakerList",
      })
      .state("speaker", {
        url: "/speakers/:id",
        component: "speakerDetail",
        resolve: {
          speaker: (SpeakerService, $stateParams) =>
            SpeakerService.getSpeaker($stateParams.id),
        },
      });
    $urlRouterProvider.otherwise("/");
  }).name;

export default speaker;
```

Como puedes ver, en el estado `speaker` correspondiente a la vista detalle, tenemos una propiedad `resolve` donde obtenemos los datos antes de cargar la vista. Utilizando funciones arrow de ES6.

De esta manera podemos hacer lo mismo para el otro estado y ahorrarnos el controller.

Vamos a refactorizar. Modificamos el estado `speakers` a√±adiendo el `resolve`:

```js
$stateProvider.state("speakers", {
  url: "/",
  component: "speakerList",
  resolve: {
    speakers: (SpeakerService) => SpeakerService.getSpeakers(),
  },
});
```

Como puedes ver gracias a las _arrow functions_ de ES6 el c√≥digo se simplifica mucho, con ES5 ser√≠a as√≠:

```js
$stateProvider
      .state('speakers', {
        url: '/',
        component: 'speakerList',
        resolve: {
          speakers: function(SpeakerService) {
             return SpeakerService.getSpeakers()
          }
      })
```

De esta forma podemos eliminar el controlador `speaker-list.controller.js` ya que su contenido ser√≠a este:

```js
class SpeakerController {
  constructor() {}
}
export default SpeakerController;
```

## M√≥dulo Components

Como ya tenemos nuestros componentes implementados, procedemos a crear un m√≥dulo de angular que recoja todos ellos:

```js
// /app/components/components.js
import angular from "angular";

import speaker from "./speaker";

const components = angular.module("app.components", [speaker]).name;

export default components;
```

En este caso s√≥lo tenemos un m√≥dulo: `speaker`, pero si tuvieramos m√°s u otros componentes los inyectar√≠amos aqu√≠.

## Ejecutando la aplicaci√≥n.

Ya no nos queda m√°s que ejecutar y probar la aplicaci√≥n. Si has tenido la tarea `npm run serve` corriendo habr√°s visto que los cambios se han ido ejecutando. Para prevenir cualquier error, paramos la tarea y corremos las siguientes en la terminal:

```shell
$ npm run build
$ npm run serve
```

Si abrimos un navegador con la url `http://localhost:3000` tendremos lo siguiente:

![Angular 1.5 + ES6/ES2015](/images/desarrollo-por-componentes-con-angular-1-5-con-es6-es2015/ezgif-1440086715.gif)

Espero que hayas aprendido algo nuevo y √∫til :). En un pr√≥ximo art√≠culo, veremos como a√±adir m√°s funcionalidades por medio de eventos.

Recuerda que tienes el c√≥digo de este tutorial en el [siguiente repositorio de GitHub](https://github.com/carlosazaustre/angularcamp-workshop).

---
title: "쯈u칠 es la autenticaci칩n basada en Token?"
date: "2015-02-19"
tags:
  - "游눹 Desarrollo"
---

Existen varios sistemas de autenticaci칩n en una aplicaci칩n web. A continuaci칩n veremos las 2 versiones m치s utilizadas junto con sus ventajas e inconvenientes.

## Autenticaci칩n en el servidor, almacenando la sesi칩n

El m치s com칰n hasta ahora era el que guardaba en una sesi칩n la informaci칩n del usuario. Para ello necesit치bamos almacenar esa informaci칩n en una base de datos, pod칤a ser una colecci칩n de <b>MongoDB</b> o en <b>Redis</b>.

Sin embargo esto supon칤a una p칠rdida de escalabilidad en nuestra aplicaci칩n, ya que el servidor debe almacenar un registro por cada vez que el usuario se autentique en el sistema. Adem치s hacemos que el Backend se encargue de ello y de esta manera si queremos desarrollar una aplicaci칩n m칩vil, necesitar칤amos otro backend diferente, no pudiendo reutilizarlo.

## Autenticaci칩n sin estado con Tokens

Por ello una de las nuevas tendencias en cuanto al desarrollo web moderno se refiere, es la autenticaci칩n por medio de _Tokens_ y que [nuestro backend sea un API RESTful sin informaci칩n de estado](/como-implementar-una-api-rest-con-mongodb-node-js-usando-express-v4/), _stateless_.

El funcionamiento es el siguiente. El usuario se autentica en nuestra aplicaci칩n, bien con un par usuario/contrase침a, o a trav칠s de un proveedor como puede ser Twitter, Facebook o Google por ejemplo. A partir de entonces, cada petici칩n HTTP que haga el usuario va acompa침ada de un _Token_ en la cabecera. Este Token no es m치s que una firma cifrada que permite a nuestro API identificar al usuario. Pero este Token no se almacena en el servidor, si no en el lado del cliente (por ejemplo en _localStorage_ o _sessionStorage_) y el API es el que se encarga de descrifrar ese Token y redirigir el flujo de la aplicaci칩n en un sentido u otro.

Como los **tokens son almacenados en el lado del cliente**, no hay informaci칩n de estado y la aplicaci칩n se vuelve totalmente escalable. Podemos usar el mismo API para diferentes apliaciones (Web, Mobile, Android, iOS, ...) solo debemos preocuparnos de enviar los datos en formato JSON y generar y descrifrar tokens en la autenticaci칩n y posteriores peticiones HTTP a trav칠s de un middleware.

![autenticaci칩n basada en Token](/images/que-es-la-autenticacion-con-token/autenticacion-basada-en-token.png)

Tambi칠n nos **a침ade m치s seguridad**. Al no utilizar cookies para almacenar la informaci칩n del usuario, podemos evitar ataques CSRF (_Cross-Site Request Forgery_) que manipulen la sesi칩n que se env칤a al backend. Por supuesto podemos hacer que el token expire despu칠s de un tiempo lo que le a침ade una capa extra de seguridad.

## Autenticaci칩n con JSON Web Tokens

El est치ndar para este tipo de autenticaci칩n es utilizar [JSON Web Tokens (JWT)](http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html). Al igual que los APIs, el formato JSON es agn칩stico del lenguaje, y podemos utilizar el que queramos (Node.js, Python, Ruby, PHP, .NET, Java,...)

El formato de un **JWT** est치 compuesto por 3 `strings` separados por un punto `.` algo as칤 como:

```shell
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1NGE4Y2U2MThlOTFiMGIxMzY2NWUyZjkiLCJpYXQiOiIxNDI0MTgwNDg0IiwiZXhwIjoiMTQyNTM5MDE0MiJ9.yk4nouUteW54F1HbWtgg1wJxeDjqDA_8AhUPyjE5K0U
```

Cada `string` significa una cosa:

- **Header**
  La primera parte es la cabecera del token, que a su vez tiene otras dos partes, el tipo, en este caso un JWT y la codificaci칩n utilizada. Comunmente es el algoritmo _HMAC SHA256_, El contenido sin codificar es el siguiente:

```js
{
	"typ": "JWT",
    "alg": "HS256
}
```

Codificado ser칤a: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`

- **Payload**
  EL _Payload_ est치 compuesto por los llamados [_JWT Claims_](http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#RegisteredClaimName) donde ir치n colocados la atributos que definen nuestro token. Exiten varios que puedes consultar aqu칤, los m치s comunes a utilizar son:
  _ `sub`: Identifica el sujeto del token, por ejemplo un identificador de usuario.
  _ `iat`: Identifica la fecha de creaci칩n del token, v치lido para si queremos ponerle una fecha de caducidad. En formato de tiempo UNIX \* `exp`: Identifica a la fecha de expiraci칩n del token. Podemos calcularla a partir del `iat`. Tambi칠n en formato de tiempo UNIX.

```js
{
	"sub": "54a8ce618e91b0b13665e2f9",
    "iat": "1424180484",
    "exp": "1425390142"
}
```

Tambi칠n podemos a침adirle m치s campos, incluso personalizados, como pueden ser el rol del usuario, etc.

```js
{
	"sub": "54a8ce618e91b0b13665e2f9",
    "iat": "1424180484",
    "exp": "1425390142",
    "admin": true,
    "role": 1
}
```

Codificado ser칤a: `eyJzdWIiOiI1NGE4Y2U2MThlOTFiMGIxMzY2NWUyZjkiLCJpYXQiOiIxNDI0MTgwNDg0IiwiZXhwIjoiMTQyNTM5MDE0MiJ9`

- **Signature**
  La firma es la tercera y 칰ltima parte del JSON Web Token. Est치 formada por los anteriores componentes (Header y Payload) cifrados en _Base64_ con una clave secreta (almacenada en nuestro backend). As칤 sirve de _Hash_ para comprobar que todo est치 bien.

```js
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret);
```

Codificado ser칤a: `yk4nouUteW54F1HbWtgg1wJxeDjqDA_8AhUPyjE5K0U`

Por tanto, todo nuestro JSON Web Token, una vez codificado tendr치 esta pinta:

```shell
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1NGE4Y2U2MThlOTFiMGIxMzY2NWUyZjkiLCJpYXQiOiIxNDI0MTgwNDg0IiwiZXhwIjoiMTQyNTM5MDE0MiJ9.yk4nouUteW54F1HbWtgg1wJxeDjqDA_8AhUPyjE5K0U
```

Que si lo comprobamos en la web [JWT.io](http://jwt.io/) vemos que nos lo traduce a los campos que hemos visto.

En la [siguiente entrada vemos como implementar **este tipo de autenticaci칩n en Node.js**](/autenticacion-con-token-en-node-js/) y m치s adelante [en el **lado cliente con AngularJS**](/autenticacion-con-token-en-angularjs/).

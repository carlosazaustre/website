---
title: "Empezando con ReactJS y ECMAScript 6"
date: "2015-06-22"
tags:
  - "游눹 Desarrollo"
---

[React.js](http://facebook.github.io) es una librer칤a de JavaScript lanzada hace poco m치s de un a침o por Facebook, normalmente utilizada en el Frontend aunque puede ser utilizada en el Backend. Facebook la utiliza en producci칩n para su red social en determinadas partes, como los comentarios y tambi칠n en Instagram.

No se trata de un framework JS de cliente como pueden ser Angular, Backbone o Ember, si no de una librer칤a que se encarga del renderizado de las vistas de una aplicaci칩n web. Es la _V_ del patr칩n _MVC_ por as칤 decirlo.

Una de las primeras cosas que vi y no me gustaban mucho de React era que parec칤a que mezclaba el HTML con c칩digo JavaScript, pero cuando lo pruebas ves que no es as칤, si no que usa un transformador de c칩digo JSX (Creado por Facebook) a JavaScript para facilitarnos la vida a la hora de programar, por ejemplo este c칩digo de React usando JSX:

```js
var Item = React.createClass({
  render: function () {
    return <div>Hello Item</div>;
  },
});
```

Y sin usar la transformaci칩n JSX ser칤a as칤:

```js
var Item = React.createClass({
  render: function () {
    return React.createElement("div", {}, "Hello Item");
  },
});
```

Commo puedes ver, se ve de una forma m치s clara con JSX lo que estamos renderizando que usando ECMAScript 5/6 puro, y eso que este ejemplo es peque침o, si estamos usando m치s elementos HTML, con clases, eventos, etc... se puede hacer inmanejable.

### Principales caracter칤sticas de React

#### DOM Virtual

Lo que ha hecho que React se vuelva _trending_ es su velocidad de renderizado de vistas. Eso es posible gracias a un _Virtual DOM_ que genera React con cada componente que creamos y el algoritmo de _Diff_ que b치sicamente lo que hace es marcar que elementos dentro de nuestro DOM Virtual tienen cambios para renderizar solo ellos y no tener que revisar y repintar el DOM entero de nuestra p치gina. D칩nde m치s tiempo se pierde en una aplicaci칩n web es en el renderizado y pintado del DOM. React evita eso y por eso es tan r치pido.

![](/images/empezando-con-react-js-y-ecmascript-6/4.png)
![](/images/empezando-con-react-js-y-ecmascript-6/5.png)
Fuente: [React's diff Algorithm](http://calendar.perfplanet.com/2013/diff/)

#### Dise침o orientado a componentes

React nos obliga a pensar en componentes. Es la nueva tendencia en el mundo del desarrollo Frontend. Al igual que en el backend se tiende a usar micro-servicios y librer칤as que resuelvan una cosa concreta, en el Frontend cada vez m치s se est치 extendiendo 칠sta pr치ctica de _componetizar_ los elementos de nuestras aplicaciones para poderlos reutilizar.

### Usando ES6 con React

Con React podemos usar el nuevo est치ndar [ECMAScript 6 (o ECMAScript 2015)](/ecmascript6t/) para escribir nuestras aplicaciones y con Babel y [Browserify](/browserify-desarrollando-tu-frontend-como-en-node-js/) tener una versi칩n traducida a ES5 que funcione en los navegadores actuales.

Si en nuestro `index.html` tenemos a침adidos los enlaces a los scripts de React.js y JSX tranformer, un componente como el anterior en ES5 es as칤:

```js
var ItemRow = React.createClass({
  render: function () {
    return <li className="Item-row">Elemento de una lista</li>;
  },
});
```

Usando ES6 e instalando las dependencias de React por npm, ser칤a algo as칤:

```js
import React from "react";

class ItemRow extends React.Component {
  render() {
    return <li className="Item-row">Elemento de una lista</li>;
  }
}

export default ItemRow;
```

A mi me parece m치s claro lo que estamos haciendo utilizando ES6. Un componente de React es una clase, que hereda de un React Component. Importamos el m칩dulo de React de forma nativa con el sistema de m칩dulos de ES6 y tambi칠n podemos exportarlo para utilizarlo en otra parte de la aplicaci칩n.

Para que esto funcione en un navegador moderno, podemos usar `Gulp` junto con unos plugins y tareas para crear la versi칩n de producci칩n. Primero necesitamos tener instaladas las siguientes dependencias:

```shell
$ npm install --save-dev browserify
$ npm install --save-dev babelify
$ npm install --save-dev vinyl-source-stream
```

Y el fichero `Gulpfile.js` con una tarea para hacer el `build` de la parte JavaScript/JSX ser칤a:

```js
// gulpfile.js

var gulp = require('gulp');
var browserify = require('browserify');
var babelify = require('babelify');
var source = require('vinyl-source-stream');

gulp.task('build', function() {
	browserify({
    	entries: './src/index.jsx',
        extensions: ['jsx'],
        debug: true
    })
    .transform(babelify)
    .bundle()
    .pipe(source('bundle.js')
    .pipe(gulp.dest('./build'))
});
```

Esta tarea toma el fichero `src/index.jsx`, el principal de la aplicaci칩n para usar browserify. Despu칠s le aplica la transformaci칩n de `babelify` que no es m치s que traducir ES6 a ES5 y crea un fichero `bundle.js` con toda nuestra aplicaci칩n y dependencias listo para usar en el navegador.

En la [siguiente entrada vemos un ejemplo de aplicaci칩n web _componetizada_ utilizando React.js y ECMAScript 6](/ejemplo-de-aplicacion-con-react-js-en-ecmascript-6/).

---
title: "Los 5 patrones del Responsive Design con Flexbox"
date: "2015-11-04"
tags:
  - "游눹 Desarrollo"
---

_Responsive Design_ significa adaptar tu dise침o al tama침o de pantalla del dispositivo. Puedes hacerlo como tu quieras, pero existen 5 patrones ya definidos que te ayudar치n en tu dise침o. Sus nombre son:

- Tiny Tweaks
- Mostly Fluid
- Column Drop
- Layout Shifter
- Off Canvas

## Tiny Tweaks

Es el patr칩n m치s simple y sencillo de implementar de todos. Se basa en una s칩la columna para el contenido.

![Patr칩n Tiny Tweaks](/images/los-5-patrones-del-responsive-design/tiny-tweaks.png)

Sus cambios son b치sicamente que dependiendo del tama침o de pantalla, se ampl칤an los espaciados y el tama침o de fuente.

Es muy utilizado en sitios con mucho contenido escrito, as칤 mejoran la experiencia de lectura.

Implementar este patr칩n en HTML y CSS ser칤a as칤:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Tiny Tweaks</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <nav>Navbar</nav>
    <section class="columna1">Secci칩n 1</section>
  </body>
</html>
```

```css
/* Tiny Tweaks */
.columna1 {
  padding: 10px;
  width: 100%;
}

@media (min-width: 600px) {
  .columna1 {
    padding: 20px;
    font-size: 1.5em;
  }
}

@media (min-width: 800px) {
  .columna1 {
    padding: 40px;
    font-size: 2em;
  }
}
```

## Mostly Fluid

Este patr칩n consiste en tener una grilla o _Grid_ de tama침o flexible.

![Patr칩n Mostly Fluid](/images/los-5-patrones-del-responsive-design/mostly-fluid.png)

Cuando estamos en un smartphone todo forma una 칰nica columna, y en varias filas quedan colocados los distintos bloques.

Seg칰n vaya creciendo la pantalla, los distintos bloques se agrupan ocupando toda la pantalla disponible.

En pantallas m치s grandes, el dise침o es el mismo pero queda agrupado dentro de un contenedor que queda centrado en la p치gina con un tama침o fijo de ancho.

Este patr칩n, implementado en HTML y CSS utilizando **Flexbox**, ser칤a as칤:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Mostly Fluid</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <nav>Navbar</nav>
    <div class="container">
      <section class="columna1">Secci칩n 1</section>
      <section class="columna2">Secci칩n 2</section>
      <section class="columna3">Secci칩n 3</section>
      <section class="columna4">Secci칩n 4</section>
      <section class="columna5">Secci칩n 5</section>
    </div>
  </body>
</html>
```

```css
/* Mostly Fluid */
.container {
  display: -webkit-flex;
  display: flex;
  -webkit-flex-flow: row wrap;
  flex-flow: row wrap;
}

.columna1,
.columna2,
.columna3,
.columna4,
.columna5 {
  width: 100%;
}

@media (min-width: 600px) {
  .columna2,
  .columna3,
  .columna4,
  .columna5 {
    width: 50%;
  }
}

@media (min-width: 800px) {
  .columna1 {
    width: 60%;
  }
  .columna2 {
    width: 40%;
  }
  .columna3,
  .columna4,
  .columna5 {
    width: 33.3%;
  }

  .container {
    width: 800px;
    margin-left: auto;
    margin-right: auto;
  }
}
```

El bloque que contiene todos los bloques (`.container`) le a침adimos la propiedad `display: flex` de _Flexbox_ y que muestre el contenido en filas `row`.

Con `wrap` indicamos que si los bloques tienen que ocupar varias filas lo hagan.

Despu칠s con un par de _Media-Queries_ disponemos dos breakpoints, uno para `600px` simulando una tablet y otro para pantallas de m치s de `800px`, simulando laptops y desktops de gran tama침o.

Para el tama침o _tablet_, hacemos que todas las columnas, salvo la primera, ocupen el 50%. De esta manera tenemos la primera columna ocupando todo el ancho de la pantalla y las restantes ocupar치n 2 filas con dos bloques cada una.

En el _breakpoint_ para pantallas de gran tama침o, hacemos que la primera columna y la segunda est칠n situadas en la primera fila, ocupando el 60% y el 40% del ancho respectivamente, y las tres restantes ocupar치n 1/3 de la fila cada una.

En este momento, al `<div>` contenedor, le damos un ancho fijo de `800px` para que el contenido quede centrado en la pantalla sin ocupar todo el ancho.

## Column Drop

Este patr칩n consiste en que cada bloque de contenido, que en un smartphone vemos en filas, vaya formando columnas seg칰n vaya siendo m치s grande la pantalla del dispositivo.

![Patr칩n Column Drop](/images/los-5-patrones-del-responsive-design/column-drop.png)

Tendremos un _primer breakpoint_ donde la segunda fila pasa a ser columna, pero ocupando la primera posici칩n, habitualmente para un men칰 de navegaci칩n.

El contenido que aparec칤a en primer lugar en la versi칩n m칩vil, pasa a ocupar la segunda columna en el primer corte.

Tendremos un segundo punto de corte donde la 칰ltima fila se convierte en columna tambi칠n.

Este ser칤a el c칩digo HTML y CSS para este patr칩n, utilizando Flexbox para ello:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Column Drop</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <nav>Navbar</nav>
    <div class="container">
      <section class="columna1">Secci칩n 1</section>
      <section class="columna2">Secci칩n 2</section>
      <section class="columna3">Secci칩n 3</section>
    </div>
  </body>
</html>
```

```css
/* Column Drop */
.container {
  display: -webkit-flex;
  display: flex;
  -webkit-flex-flow: row wrap;
  flex-flow: row wrap;
}

.columna1,
.columna2,
.columna3 {
  width: 100%;
}

@media (min-width: 600px) {
  .columna1 {
    width: 60%;
    -webkit-order: 2;
    order: 2;
  }

  .columna2 {
    width: 40%;
    -webkit-order: 1;
    order: 1;
  }

  .columna3 {
    width: 100%;
    -webkit-order: 3;
    order: 3;
  }
}

@media (min-width: 800px) {
  .columna2,
  .columna3 {
    width: 20%;
  }
}
```

Para poder colocar con mayor facilidad la segunda fila en primera columna, hemos empleado la propiedad `order` de Flexbox, indic치ndole con un n칰mero que posici칩n debe ocupar.

## Layout Shifter

Este es uno de los patrones m치s complejos. Consiste en mover los bloques de contenido cambiando totalmente el _Layout_, de ah칤 el nombre del patr칩n.

![Patr칩n Layout Shifter](/images/los-5-patrones-del-responsive-design/layout-shifer.png)

Gracias a Flexbox, estos cambios podemos realizarlos con mayor facilidad.

Las columnas 2 y 3 estar치n englobadas dentro de un bloque que llamaremos `container-inner` que nos permitir치 hacer el cambio de _layout_.

De nuevo, el c칩digo HTML y CSS para este patr칩n resultar칤a as칤:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Layout Shifter</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <nav>Navbar</nav>
    <div class="container">
      <section class="columna1">Secci칩n 1</section>
      <div class="container-inner">
        <section class="columna2">Secci칩n 2</section>
        <section class="columna3">Secci칩n 3</section>
      </div>
    </div>
  </body>
</html>
```

```css
/* Layout Shifter */
.container {
  display: -webkit-flex;
  display: flex;
  -webkit-flex-flow: row wrap;
  flex-flow: row wrap;
}

.columna1,
.columna2,
.columna3,
.container-inner {
  width: 100%;
}

@media (min-width: 600px) {
  .columna1 {
    width: 25%;
    height: 100vh;
  }

  .container-inner {
    width: 75%;
  }
}

@media (min-width: 800px) {
  .container {
    width: 800px;
    margin-left: auto;
    margin-right: auto;
  }
}
```

De nuevo, a partir del _breakpoint_ de `800px`, fijamos un ancho para el contenedor de manera que no ocupe toda la p치gina.

## Off Canvas

Para el final he dejado el patr칩n m치s complejo de implementar pero uno de los m치s utilizados, sobre todo en aplicaciones m칩vile.

![Patr칩n Off Canvas](/images/los-5-patrones-del-responsive-design/off-canvas.png)

Este patr칩n esconde contenido en la pantalla y 칰nicamente es visible si realizamos un determinado gesto. Este contenido oculto normalmente es un men칰 de navegaci칩n. Cuando la pantalla es m치s ancha, este contenido se hace visible.

El HTML para la p치gina ser칤a el habitual:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Off Canvas</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <nav>Navbar</nav>
    <div class="container">
      <section class="columna1">Secci칩n 1</section>
      <section class="columna2">Secci칩n 2</section>
    </div>
  </body>
</html>
```

Y el CSS vamos a verlo paso a paso

En primer lugar, la columna 1 que ser치 la que aparezca oculta, le damos un ancho fijo, y le a침adimos un `position: absolute`.

Tambi칠n le aplicamos una transici칩n CSS a la transformaci칩n que vamos a declarar a continuaci칩n

```css
.columna1 {
  position: absolute;
  width: 250px;
  height: 100vh;
  -webkit-transition: -webkit-transform 0.3s ease-out;
  transition: transform 0.3s ease-out;
  z-index: 1;
}
```

La transformaci칩n consiste en 2 fases. Para ocultar la capa, le aplicamos la transformaci칩n `translate(-250px, 0)` que lo que hace es "mover" la capa 250px hacia la izquierda en el eje X. Como el tama침o de la capa le hemos definido en 250px, quedar치 oculto

Tambi칠n creamos una clase `columna1 open` que a침adiremos con JavaScript m치s adelante. Esta clase "mueve" a la posici칩n 0 del eje X la capa, lo que hace sea visible.

Como hemos aplicado una `transition` este efecto ser치 suave y otorga una mayor experiencia de usuario.

```css
.columna1 {
  -webkit-transform: translate(-250px, 0);
  transform: translate(-250px, 0);
}

.columna1.open {
  -webkit-transform: translate(0, 0);
  transform: translate(0, 0);
}
```

La columna 2 (central) no tiene mayor misterio. Queremos que ocupe el 100% del ancho y todo el alto de la p치gina.

```css
.columna2 {
  width: 100%;
  height: 100vh;
  position: absolute;
}
```

Cuando la pantalla sea m치s ancha, vamos a aplicar al contenedor padre las propiedades de Flexbox. Esta vez el a침adimos la propiedad `nowrap` que hace que el tama침o de ancho de los bloques de adapte en una sola fila, sin crear varias.

Ahora la columna que estaba oculta, la sacamos a la luz, aplicando la transformaci칩n de `translate(0,0)`

```css
@media (min-width: 600px) {
  .container {
    display: -webkit-flex;
    display: flex;
    -webkit-flex-flow: row nowrap;
    flex-flow: row nowrap;
  }

  .columna1 {
    -webkit-transform: translate(0, 0);
    transform: translate(0, 0);
  }
}
```

Muy bien, ahora es momento de _aplicar magia_ con JavaScript. Queremos que al hacer el t칤pico gesto de _swipe_ en el m칩vil hacia la derecha, aparezca el men칰 _off-canva_, y al hacer el gesto contrario se oculte hacia la izquierda.

Podemos usar los eventos nativos de JavaScript `touchstart` y `touchmove` pero el c칩digo puede quedar demasiado farragoso.
Para solucinar esto tenemos la libreria [Hammer.js](http://hammerjs.github.io/) que tiene programados los diferentes gestos que podemos usar en un tel칠fono o tablet.

Para aplicar esto, lo primero que vamos a hacer es a침adir unos `id` a los paneles en el HTML:

```html
<div class="container">
  <section id="sidePanel" class="c1">Secci칩n 1</section>
  <section id="mainPanel" class="c2">Secci칩n 2</section>
</div>
```

`sidePanel` ser치 el panel _off-canva_ y `mainPanel` ser치 el panel principal.

A침adimos tambi칠n al HTML el script con la librer칤a **Hammer.js**. Podemos usar una local descargada o un CDN como he puesto en el ejemplo.

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.4/hammer.min.js"></script>
```

Y a continuaci칩n a침adimos el c칩digo que detectar치 los eventos `swiperight` cuando arrastremos el dedo hacia la derecha y `swipeleft` cuando lo hagamos al contrario. Estos eventos ir치n adjuntos al elemento `mainPanel` que ser치 el que los escuche.

Por tanto primero _cacheamos_ los elementos `sidePanel` y `mainPanel`, y despu칠s se los a침adimos a un objeto `Hammer` que lo gestionar치.

Cuando el evento ocurra, simplemente queremos que se a침ada la clase de CSS `open` al `sidePanel` en el caso de que no est칠 a침adida, y si no que la quite. Esto lo conseguimos con la funci칩n de JS `toggle`. El c칩digo JS final ser칤a as칤:

```javascript
(function () {
  var mainPanel = document.getElementById("mainPanel");
  var sidePanel = document.getElementById("sidePanel");

  var hammerPanel = new Hammer(mainPanel);

  hammerPanel
    .on("swiperight", function (e) {
      sidePanel.classList.toggle("open");
    })
    .on("swipeleft", function (e) {
      sidePanel.classList.toggle("open");
    });
})();
```

---

Con esto tendr칤amos los 5 patrones de dise침o Responsive implementados sin necesidad de frameworks. Todos ellos pueden combinarse entre s칤, por ejemplo usar _Off-Canvas_ con un _Column Drop_ que use a su vez _Tiny Tweaks_. Todo es posible!

Si quieres seguir profundizando sobre esto te dejo algunas referencias:

- [Google Web Fundamentals - Responsive Design Patterns](https://developers.google.com/web/fundamentals/design-and-ui/responsive/patterns/?hl=en)
- [Multidevice Layout Patterns](http://www.lukew.com/ff/entry.asp?1514)
- [Visual Guide to CSS3 Flexbox Properties](https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties)
- [El gran poder de CSS3 Flexbox](http://filisantillan.com/el-gran-poder-de-css3-flexbox/)

De esto y mucho m치s hablo en el [Curso de **Responsive Design** en Platzi](https://platzi.com/cursos/responsive-design/?utm_source=carlosazaustre&utm_medium=cta&utm_campaign=responsive-design)

---
title: "C贸mo implementar autenticaci贸n basada en token con Node.js"
date: "2015-02-23"
tags:
  - " Desarrollo"
---

En el [anterior post vimos las bases de la autenticaci贸n basada en token en una aplicaci贸n web](/que-es-la-autenticacion-con-token/). En este post, vamos a ver como implementar este tipo de **autenticaci贸n en un servidor usando Node.js**

Voy a separar las funciones en varios archivos, siguiendo buenas pr谩cticas y modularizando dependendiendo de la funcionalidad.

#### Nuestro servidor en Node.js

Lo primero es crear el archivo `server.js` d贸nde configuramos Express (en versi贸n 4), importamos los m贸dulos necesarios y hacemos correr el servidor y la base de datos.

Si te pierdes un poco, en [茅ste post anterior expliqu茅 como crear un API REST en Node.js con Express y MongoDB](/como-crear-una-api-rest-usando-node-js/). Y si prefieres tambi茅n tengo un [videotutorial en YouTube sobre el tema](https://www.youtube.com/watch?v=SKoK6braZlk&list=PLUdlARNXMVkl9MJl4r90Z1j1nmAfWEPV3).

Configuraci贸n b谩sica de un servidor en Node.js utilizando Express v4.

```js
// server.js
var express = require('express');
var bodyParser = require('body-parser');
var mongoose = require('mongoose');
var cors = require('cors');
var authCtrl = require('./auth');
var middleware = require('./middleware');

// Configuramos Express
var app = express();
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({extended: true}));
app.use(cors());
app.set('port', 3000);

// Importamos nuestros modelos,
// en este ejemplo nuestro modelo de usuario
require('./models/user');

// Iniciamos las rutas de nuestro servidor/API
var router = express.Router();

// Rutas de autenticaci贸n y login
router.post('/auth/signup', auth.emailSignup);
router.post('/auth/login', auth.emailLogin);

// Ruta solo accesible si est谩s autenticado
router.get('/private',middleware.ensureAuthenticated, function(req, res) {...} );

// Iniciamos el servidor y la base de datos
mongoose.connect('mongodb://localhost', function(err) {
	// Comprobar errores siempre
    app.listen(app.get('port'), function(){
    	console.log('Express corriendo en http://localhost:3000');
    });
});

```

Simplemente hemos importado los m贸dulos necesarios y la configuraci贸n b谩sica de Express. Tambi茅n he importado un archivo con el _Schema_ del modelo `User` donde almacenaremos nuestros usuarios. Las rutas que utilizaremos ser谩n `/auth/signup` para el registro con email y contrase帽a y `/auth/login` para autenticarnos.

Luego tendremos una ruta adicional, `/private` que s贸lo podremos acceder a ella si estamos logueados. Si nos fijamos, he creado un middleware para esta 煤ltima ruta, que se ejecutar谩 antes de la funci贸n controladora. Lo he separado en un m贸dulo aparte, de esta manera podemos reutilizar esta funci贸n en todas las rutas que queramos que sean privadas.

De igual manera, en las funciones controladores de `/auth/signup` y `/auth/login` utilizo otras funciones importadas como son `auth.emailSignup` y `auth.emailLogin` que definiremos a continuaci贸n.

#### Controladores

En el fichero `auth.js` voy a definir las dos funciones controladoras para el registro y autenticaci贸n de usuarios.

```js
// auth.js
var mongoose = require("mongoose");
var User = mongoose.model("User");
var service = require("./service");

exports.emailSignup = function (req, res) {
  var user = new User({
    // Creamos el usuario con los campos
    // que definamos en el Schema
    // nombre, email, etc...
  });

  user.save(function (err) {
    return res.status(200).send({ token: service.createToken(user) });
  });
};

exports.emailLogin = function (req, res) {
  User.findOne({ email: req.body.email.toLowerCase() }, function (err, user) {
    // Comprobar si hay errores
    // Si el usuario existe o no
    // Y si la contrase帽a es correcta
    return res.status(200).send({ token: service.createToken(user) });
  });
};
```

En `emailSignup` creo un nuevo usuario, con los campos que estimemos necesarios para nuestra aplicaci贸n, por ejemplo el email, nombre, contrase帽a, etc... Despues de salvar el usuario, enviamos un c贸digo `200` de OK en la respuesta, junto con un mensaje en el que pasaremos el token que creamos en la funci贸n `service.createToken()` que veremos a continuaci贸n.

Para el `emailLogin`, buscamos primero si el usuario existe y comprobamos que la contrase帽a es correcta o no. Si todo es OK, volvemos a enviar un c贸digo `200` en la respuesta HTTP junto con el token.

#### Codificando el JSON Web Token

Ahora vamos al "meollo" de este art铆culo, la creaci贸n de un Token que identifique a nuestro usuario en cada petici贸n HTTP que realice.

Para codificar el token utilizamos una clave secreta. Es importante que esta clave permanezca lo m谩s oculta posible. Una opci贸n es almacenarla en un fichero `config.js` y ese fichero no subirlo al repositorio con `.gitignore` o la opci贸n mejor es utilizar una variable de entorno (con `process.env`) que est茅 en nuestro servidor, y otra para nuestro entorno de desarrollo.

Ser铆a algo as铆:

```js
// config.js
module.exports = {
  TOKEN_SECRET: process.env.TOKEN_SECRET || "tokenultrasecreto",
};
```

Cuando importemos el fichero `config.js` en la variable `TOKEN_SECRET` tendremos nuestra clave para codificar.

Creamos el servicio que utilizaremos para codificar el token. Para ello vamos utilizar la librer铆a [jwt-simple](https://www.npmjs.com/package/jwt-simple) que nos facilita la vida a la hora de codificar el _payload_ y hace todo el trabajo que expliqu茅 en el [post anterior](/que-es-la-autenticacion-con-token/).

```js
// services.js
var jwt = require("jwt-simple");
var moment = require("moment");
var config = require("./config");

exports.createToken = function (user) {
  var payload = {
    sub: user._id,
    iat: moment().unix(),
    exp: moment().add(14, "days").unix(),
  };
  return jwt.encode(payload, config.TOKEN_SECRET);
};
```

Creamos un objeto `payload` en el que ponemos tres atributos: `sub`, `iat` y `exp`. Que ya [explicamos anteriormente](/que-es-la-autenticacion-con-token/). En `sub` almacenamos el ID del usuario que pasamos por par谩metro.

Tambi茅n usamos la librer铆a [moment](http://momentjs.com) para ayudarnos en el manejo de fechas. Con `moment().unix()` conseguimos el tiempo actual en formato UNIX, y con `moment().add(14, "days").unix()` le estamos a帽adiendo 14 d铆as al momento actual. Muy 煤til para establecer una fecha de creaci贸n y expiraci贸n.

Por 煤litmo devolvemos el JSON Web Token, codificando el payload con nuestra clave secreta.

#### Acesso a rutas con autenticaci贸n.

Cada vez que accedamos a una ruta privada, s贸lo accesible si estamos autenticados, como por ejemplo `/private`, le pasamos el middleware `ensureAuthenticated` que a continuaci贸n programaremos:

```js
// middleware.js
var jwt = require("jwt-simple");
var moment = require("moment");
var config = require("./config");

exports.ensureAuthenticated = function (req, res, next) {
  if (!req.headers.authorization) {
    return res
      .status(403)
      .send({ message: "Tu petici贸n no tiene cabecera de autorizaci贸n" });
  }

  var token = req.headers.authorization.split(" ")[1];
  var payload = jwt.decode(token, config.TOKEN_SECRET);

  if (payload.exp <= moment().unix()) {
    return res.status(401).send({ message: "El token ha expirado" });
  }

  req.user = payload.sub;
  next();
};
```

Lo primero que hacemos en la funci贸n es comprobar que la petici贸n, `req` lleva la cabecera de autorizaci贸n `req.headers.authorization`. sto lo env铆a el Frontend y lo veremos en un pr贸ximo post, con Angular.js

Si la petici贸n no env铆a una autorizaci贸n, env铆amos el c贸digo de error `403` de acesso denegado. y si no, tomamos el token.

la cabecera, tendr谩 una pinta parecida a 茅sta:

```js
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbsciOiJIUzI1NiJ9.eyJzdWIiOiIWeRtU2ZWMyYjUyNjgxNzE2YmXiNzAxMzIiLCJpYXQiOjE0Mj10MjA0OTEsImV4cCI6MTQy67YzMDA5MX0.IH7ek7Rp_WQJvXeOd8zrBIpeFi4W6kUi_6htmaxv7Ow
```

S贸lo tenemos que obtener el token de ese String y lo hacemos con el m茅todo `split` de JavaScript:

```js
var token = req.headers.authorization.split(" ")[1];
```

Decodificamos ese token con la funci贸n `decode` y la clave secreta y ya podemos identificar al usuario, con el atributo `sub` del objeto `payload`, que seg煤n este ejemplo ser谩n un ObjectID de Mongo.

En la pr贸xima entrada, veremos [c贸mo programar la autenticaci贸n en la parte del cliente con Angular.js](/autenticacion-con-token-en-angularjs/).

---
title: "쮺칩mo funciona Redux? Conceptos b치sicos"
date: "2017-03-09"
tags:
  - "游눹 Desarrollo"
---

En el [anterior post vimos que era y c칩mo funcionaba la arquitectura Flux](/como-funciona-flux/). Siendo de alguna manera, un sustituto o evoluci칩n del patr칩n Modelo-Vista-Controlador.

Al igual que existe la programaci칩n orientada a objetos y existen lenguajes que lo implementan (Como Java por ejemplo), o el patr칩n MVC y existen frameworks o librer칤as que lo implementan (como AngularJS o Backbone por ejemplo), **[Redux](http://redux.js.org) es una librer칤a que implementa el patr칩n de dise침o Flux**, con algunas variaciones que veremos a lo largo del art칤culo.

Redux es una librer칤a JavaScript muy peque침a (Apenas 2KB en total), con muy poco c칩digo. Su API apenas son 5 funciones y lo m치s importante es que es JavaScript puro, por lo que es agn칩stica al framework y puede utilizarse con cualquier librer칤a framework (Angular, Polymer, React, etc...)

![Redux Logo](/images/como-funciona-redux-conceptos-basicos/logo_redux.png)

## 쯈u칠 hace Redux?

Redux se encarga en cierta manera de desacoplar el estado global de una aplicaci칩n web (en Front-End) de la parte visual, es decir los componentes.

Seguramente te preguntes 쯈u칠 es el estado de la aplicaci칩n?

### El estado de la aplicaci칩n

El estado en una web o aplicaci칩n pueden ser varias cosas, normalmente se trata **los datos que puedes recibir a trav칠s de un API REST o WebService** (por ejemplo un listado de productos), tambi칠n se refiere al **estado de la UI** en un determinado momento, por ejemplo: un panel est치 desplegado o no, tiene que aparecer la informaci칩n del usuario o no, un mensaje de error, etc...

Para llevar a cabo esta gesti칩n del estado, Redux implementa Flux pero con algunas modificaciones:

## Los 3 conceptos clave de Redux

Redux se base en tres conceptos principales:

### 1. Una 칰nica "fuente de la verdad"

Flux propone que haya varios _Stores_ para almacenar el estado. Sin embargo Redux simplifica esto utilizando un 칰nico _Store_. Todo el estado queda almacenado en un 치rbol. En JavaScript esto se conseguir칤a con un objeto JavaScript como el siguiente:

```javascript
const initialState = {
  user: {
    error: null,
    isLoading: true,
    avatar: null,
    email: null,
  },
  products: {
    list: [],
    error: null,
    isLoading: true,
  },
};
```

### 2. El estado es de s칩lo lectura.

No podemos modificar el estado directamente, s칩lo podemos leer de 칠l para representarlo en la vista y si queremos modificarlo, lo tenemos que hacer a trav칠s de **acciones**.

Una acci칩n es simplemente un objeto JavaScript que incluye al menos un atributo `type` que indica el tipo de acci칩n que estamos emitiendo y en caso de que haya datos asociados al cambio o modificaci칩n, un atributo `payload` con esos datos:

```javascript
{
   type: 'LOAD_PRODUCTS',
   products: products
}
```

Estas acciones suelen devolverse a trav칠s de un _Action Creator_ que ser칤a de este tipo:

```javascript
function loadProducts(products) {
  return {
    type: "LOAD_PRODUCTS",
    products,
  };
}
```

### 3. Cambios con funciones puras.

Ya que no podemos modificar el estado directamente (tiene que ser a trav칠s de acciones) y el estado est치 almacenado en un 칰nico _Store_, para especificar como realizar los cambios en el 치rbol del estado utilizamos funciones puras llamadas **reducers**.

Una funci칩n pura es simplemente una funci칩n que ante los mismos datos de entrada devuelve el mismo resultado. Es decir, la siguiente funci칩n ser칤a una funci칩n pura de ejemplo:

```javascript
function suma(a, b) {
  return a + b;
}
```

Esta funci칩n para los mismos par치metros, devuelve siempre lo mismo. Si llamamos a `suma(1,2)` siempre devolver치 3. De 칠sta manera es m치s sencillo depurar y encontrar errores, y es m치s f치cil testear.

El **reducer** es simplemente eso, una funci칩n que recibe dos par치metros, el estado inicial y una acci칩n y dependiendo del tipo de acci칩n realizar치 una operaci칩n u otra en el estado. Siempre de manera inmutable, no podemos modificar el estado, si no crear una copia a partir del anterior. De esta forma es m치s f치cil rastrear posibles errores.

Un _reducer_ tiene esta pinta:

```javascript
function reducer (state, action) {
   switch(action.type) {
     case 'ADD_ITEM':
       return state.concat(action.item);
     case 'REMOVE_ITEM':
     ...
     default:
       return state;
   }
}
```

## API de Redux

Como comentaba anteriormente, el API o funciones que exporta Redux son muy pocas. Vamos a explicar aqu칤 las m치s utilizadas cuando creas una aplicaci칩n con Redux:

### createStore

Esta funci칩n, como su nombre indica, crea la _store_ central donde se almacenar치 el estado global de la aplicaci칩n.

La funci칩n recibe como par치metro un _reducer_ y opcionalmente un estado inicial y un _enhancer_ que nos sirve para m치s adelante a침adir _Middlewares_. Y devuelve la _store_ creada.

```javascript
const store = redux.createStore(reducer, [initialState], [enhancer]);
```

Con la _Store_ creada tenemos [varios m칠todos](https://redux.js.org/api/store#store-methods) que podemos utilizar:

- `store.getState()`: Nos devuelve el estado actual de la _store_.
- `store.dispatch(action)`: Emite una acci칩n, es la 칰nica forma de intentar cambiar el estado.
- `store.subscribe(listener)`: Permite suscribirse a los cambios que ocurran. El `listener` es llamado cada vez que una acci칩n sea emitida y una parte del estado pueda haber sido cambiada.

Hay otros m치s pero estos son los m치s utilizados.

### combineReducers

Como en Redux tenemos un 칰nico _store_ para almacenar todo el estado de la aplicaci칩n. Es una buena pr치ctica tener varios _reducers_ (uno por cada parte desglosada del estado) y con esta funci칩n podemos combinarlos en un 칰nico _reducer_ que pasar como par치metro a la funci칩n `createStore`.

**쯇or qu칠 hay que hacer varios _reducers_?** Porque de esta forma dividimos nuestro problema en varias partes y es m치s sencillo modularizar nuestra aplicaci칩n.

Por ejemplo si tenemos un estado como el siguiente:

```javascript
const initialState = {
  user: {
    error: null,
    email: null,
  },
  products: {
    list: [],
    loading: true,
    error: null,
  },
  currentProduct: {
    product: null,
    loading: true,
    error: null,
  },
  cart: {
    items: [],
    total: 0,
  },
};
```

Ser칤a interesante tener un _reducer_ que controle la parte del estado dedicada al `user`, otro reducer para todas las acciones asociadas a la manipulaci칩n de los `products`. Otro m치s para el producto actual y otro para la gesti칩n del carrito, de tal manera que podamos hacer lo siguiente:

```javascript
function userReducer (state = initialState.user, action) {...}
function productsReducer (state = initialState.products, action) {...}
function currentProductReducer (state = initialState.currentProduct, action) {...}
function cartReducer (state = initialState.cart, action) {...}

const rootReducer = combineReducers({
  user: userReducer,
  products: productsReducer,
  currentProduct: currentProductReducer,
  cart: cartReducer
});
```

### applyMiddleware

Esta funci칩n nos permite a침adir _Middlewares_ a Redux. Los _middlewares_ son funciones que se ejecutan entre que se emite una acci칩n y cambia el estado. Podemos a침adir multitud de ellos, y uno de los m치s usados ser칤a **Redux-Thunk** que veremos en otro post ;)

### bindActionCreators

Esta funci칩n nos permite enlazar la funci칩n `dispatch` de la _store_ con los creadores de acci칩n (esto son funciones que devuelven el objeto acci칩n) de manera que no tengamos que estar importando la _store_ en todas las partes que necesitemos emitir una acci칩n.

Es muy utilizada con React y sobre todo con la librer칤a `react-redux` que nos permite escribir menos c칩digo si utilizamos Redux con React.

### compose

Dependiendo del tipo o tipos de _middlewares_ que estemos incluyendo en la creaci칩n del nuestra _store_, ser치 necesario unirlos para que funcione correctamente (por ejemplo la extensi칩n de Chrome Redux Developer Tools hay que incluirla en la _store_ con 칠sta funci칩n).

En resumen, lo que necesitas para utilizar Redux es:

- Definir tu **estado inicial**.
- Trocear ese estado inicial para crear **varios reducers** (o uno solo si tu estado no es muy complejo)
- Definir las acciones (tipos y datos a recibir) y tambi칠n crear las funciones creadoras de acci칩n (_Actions Creators_).
- Component los reducers si tienes varios, en uno solo.
- Crear la store

Luego ya dependiendo de si te ayudas de librer칤as espec칤ficas para cada framework o librer칤a que utilices, ya funciona de una forma u otra.

Y b치sicamente esto es Redux. Resulta un tanto lioso y abrumante al principio, pero en un pr칩ximo tutorial crear칠 una aplicaci칩n de ejemplo, explicada paso a paso para entender como se conecta todo esto.

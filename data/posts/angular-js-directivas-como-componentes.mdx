---
title: "C칩mo programar orientado a Componentes con Directivas de Angular 1.x"
date: "2015-11-17"
tags:
  - "游눹 Desarrollo"
---

En este art칤culo vamos a ver como desarrollar nuestras aplicaciones web en Angular JS siguiendo varios consejos de **buenas pr치cticas** y c칩mo **utilizar directivas para componentizar** nuestra web.

## Introducci칩n

Normalmente si sigues el tutorial de la [p치gina de AngularJS](https://docs.angularjs.org/tutorial) o los cursos online de [CodeSchool](https://www.codeschool.com/courses/shaping-up-with-angular-js) y [CodeAcademy](https://www.codecademy.com/learn/learn-angularjs) para aprender a usar AngularJS, encontrar치s que todos los ejemplos los hacen utilizando `$scope`.

`$scope` es un servicio de AngularJS que nos permite comunicar la vista (HTML) con el c칩digo de controlador (JavaScript).

El problema es que en **la nueva versi칩n de Angular (La 2.0) el `$scope` ya no existe** y hay varias gu칤as de **buenas pr치cticas** d칩nde nos recomiendan no utilizarlo y emplear en su lugar el objeto `this` en el controlador y la directiva `controller as` para utilizar un alias en la vista.

Desde hace tiempo, a la hora de programar en AngularJS utilizo estas buenas pr치cticas. [En concreto las de **John Papa**](https://github.com/johnpapa/angular-styleguide), un Google Developer Expert. Si las sigues, **tu c칩digo de AngularJS ser치 m치s limpio, legible y mantenible**. Adem치s lo tendr치s preparado para cuando quieras dar el salto a Angular 2.0, ya que la nueva versi칩n sigue esta metodolog칤a en cierta medida.

Otra [buena gu칤a de buenas pr치cticas en AngularJS es la de **Todd Motto**](https://github.com/toddmotto/angularjs-styleguide), otro Google Developer Expert. Ambas son grandes gu칤as y pueden complementarse.

## Forma tradicional

Imaginemos una peque침a aplicaci칩n web con AngularJS que pinte una lista de productos. Simplemente tenemos nuestro `index.html` y nuestro c칩digo javascript en `app.js` donde estar치 el controlador de la vista y un servicio que simula la entrega de los datos.

Siguiendo la forma tradicional, utilizamos `$scope` para acoplar la vista al c칩digo.

Esto ser칤a el HTML

```html
<div ng-app="myApp" ng-controller="MyController">
  <h1>Listado de Productos</h1>
  <ul>
    <li ng-repeat="producto in productos">
      <strong>{{ producto.titulo }}</strong>: {{ producto.precio | currency }}
    </li>
  </ul>
</div>
```

Y esto nuestro fichero `app.js`

```javascript
angular
  .module("myApp", [])
  .controller("MyController", MyController)
  .service("MyService", MyService);

function MyController($scope, MyService) {
  $scope.productos = MyService.getData();
}

function MyService() {
  return {
    getData: getData,
  };

  function getData() {
    var datos = [
      { titulo: "Producto 1", precio: 2 },
      { titulo: "Producto 2", precio: 1.5 },
      { titulo: "Producto 3", precio: 4.2 },
      { titulo: "Producto 4", precio: 3 },
      { titulo: "Producto 5", precio: 2.5 },
    ];
    return datos;
  }
}
```

## Prescindiendo de $scope

La **alternativa a `$scope` es utilizar un alias en el controlador** con `Controller As` y emplear el objeto `this` en el controlador para acceder a los elementos de la vista.

Este ser칤a el cambio en la vista HTML:

```html
<div ng-app="myApp" ng-controller="MyController as my">
  <h1>Listado de Productos</h1>
  <ul>
    <li ng-repeat="producto in my.productos">
      <strong>{{ producto.titulo }}</strong>: {{ producto.precio | currency }}
    </li>
  </ul>
</div>
```

Y en el c칩digo de `app.js` vemos el cambio de `$scope` por `this`.

```javascript
angular
  .module("myApp", [])
  .controller("MyController", MyController)
  .service("MyService", MyService);

function MyController(MyService) {
  this.productos = MyService.getData();
}

function MyService() {
  return {
    getData: getData,
  };

  function getData() {
    var datos = [
      { titulo: "Producto 1", precio: 2 },
      { titulo: "Producto 2", precio: 1.5 },
      { titulo: "Producto 3", precio: 4.2 },
      { titulo: "Producto 4", precio: 3 },
      { titulo: "Producto 5", precio: 2.5 },
    ];
    return datos;
  }
}
```

Esto es una buena pr치ctica porque nos permite tener controladores anidados y que no entren en conflicto.

Adem치s **el c칩digo es m치s legible** y te prepara para poder usar los **controladores como [clases de ECMAScript 6](/ecmascript6)** que ser치 lo que utilicemos en el futuro con Angular 2.0.

### Usando rutas y vistas

Cuando nuestra aplicaci칩n se va volviendo m치s compleja necesitamos echar mano de rutas. Para ello en nuestro HTML debemos a침adir la directiva `ng-view` para indicar a Angular d칩nde se insertar치n las vistas asociadas a las rutas.

Aparte debemos incluir entre los scripts la librer칤a de `angular-route.js` ya que 칠ste m칩dulo no forma parte del core de Angular.

```html
<div ng-app="myApp">
  <div ng-view></div>
</div>
```

En nuestro c칩digo JavaScript debemos incluir el m칩dulo `ngRoute` dentro de las dependencias de nuestro m칩dulo principal `myApp`, para poder acceder al servicio `$routeProvider`

Las rutas se configuran dentro del `config` de m칩dulo, y cada ruta lleva su URL al template HTML que se cargar치 con determinada ruta, su controlador y su alias.

El c칩digo para utilizar el controlador y plantilla que est치bamos usando hasta ahora, pero con rutas, ser칤a el siguiente:

```javascript
angular
  .module("myApp", ["ngRoute"])
  .config(appConfig)
  .controller("MyController", MyController)
  .service("MyService", MyService);

function appConfig($routeProvider) {
  $routeProvider.when("/", {
    templateUrl: "tpl/listado.html",
    controller: "MyController",
    controllerAs: "my",
  });
}

function MyController(MyService) {
  this.productos = MyService.getData();
}

function MyService() {
  return {
    getData: getData,
  };

  function getData() {
    var datos = [
      { titulo: "Producto 1", precio: 2 },
      { titulo: "Producto 2", precio: 1.5 },
      { titulo: "Producto 3", precio: 4.2 },
      { titulo: "Producto 4", precio: 3 },
      { titulo: "Producto 5", precio: 2.5 },
    ];
    return datos;
  }
}
```

Y el HTML de la plantilla, ser칤a tal que as칤 en un fichero `tpl/listado.html` como hemos definido en el `$routeProvider`.

```markup
<h1>Listado de Productos</h1>
<ul>
  <li ng-repeat="producto in my.productos">
    <strong>{{ producto.titulo }}</strong>: {{ producto.precio | currency }}
  </li>
</ul>
```

## Creando una directiva

En Angular tenemos directivas, que actualmente son lo que conocemos como WebComponents, pero en el momento que se cre칩 Angular esto a칰n no exist칤a, es por ello que **en Angular 2 se utilizar치n los WebComponents de forma nativa para ello**.

Creando directivas, podemos reutilizar controladores y vistas, creando de esta forma componentes reutilizables. Es el m칠todo de **programaci칩n orientada a componentes** que siguen librer칤as como Polymer o [React](/empezando-con-react-js-y-ecmascript-6/)

Con AngularJS podemos seguir esta metodolog칤a utilizando directivas.

Si asociamos el controlador anterior y el HTML de la plantilla en una directiva, el c칩digo ser칤a el siguiente:

```javascript
function miDirectiva() {
  return {
    scope: {},
    templateUrl: "tpl/listado.html",
    controller: "MyController",
    controllerAs: "my",
  };
}
```

De esta manera, tendr칤amos una directiva o tag HTML as칤: `<mi-directiva></mi-directiva>`, que nada nos impide utilizarlo en la configuraci칩n de las rutas en `$routeProvider` con la propiedad `template`, quedando m치s legible esta configuraci칩n.

```javascript
function appConfig($routeProvider) {
  $routeProvider.when("/", {
    template: "<mi-directiva></mi-directiva>",
  });
}
```

Esta forma de utilizar las directivas en rutas [la utiliza mucho el equipo de ingenier칤a de PayPal como comentan en **칠ste** art칤culo.](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef)

## Simplificando la directiva como componente

Aunque hemos creado una directiva seguimos utilizando una plantilla HTML externa y un controlador.

En las directivas de Angular podemos englobar todo dentro de la misma funci칩n utilizando los atributos `controller`, `controller as` y `template`.

El `app.js` complto con la configuraci칩n, el servicio y la directiva ser칤a el siguiente:

```javascript
angular
  .module("myApp", ["ngRoute"])
  .config(appConfig)
  .service("MyService", MyService)
  .directive("miDirectiva", miDirectiva);

function appConfig($routeProvider) {
  $routeProvider.when("/", {
    template: "<mi-directiva></mi-directiva>",
  });
}

function miDirectiva() {
  return {
    scope: {},
    controller: function (MyService) {
      this.productos = MyService.getData();
    },
    controllerAs: "vm",
    template: [
      "<h1>Listado de Productos</h1>",
      "<ul>",
      '<li ng-repeat="producto in vm.productos">',
      "<strong>{{ producto.titulo }}</strong>: {{ producto.precio | currency }}",
      "</li>",
      "</ul>",
    ].join(""),
  };
}

function MyService() {
  return {
    getData: getData,
  };

  function getData() {
    var datos = [
      { titulo: "Producto 1", precio: 2 },
      { titulo: "Producto 2", precio: 1.5 },
      { titulo: "Producto 3", precio: 4.2 },
      { titulo: "Producto 4", precio: 3 },
      { titulo: "Producto 5", precio: 2.5 },
    ];
    return datos;
  }
}
```

Trabajando de esta manera me recuerda a la [forma de trabajar con React](/ejemplo-de-aplicacion-con-react-js-en-ecmascript-6/) cuando empezamos a armar nuestras aplicaciones.

## Anidando directivas y usando atributos para pasar datos

Vale, esto est치 muy bien pero que pasa si quieros usar directivas dentro de otras, y poder pasarle par치metros de una a otra.

Muy sencillo, imaginemos que `<mi-directiva>` pintar치 una lista de componentes `<mi-item>` que ahora definiremos, pero estos `<mi-item>` tienen un atributo `data` donde le pasamos el objeto que queramos que pinte.

Nuestra directiva `<mi-directiva>` ser치 as칤:

```javascript
function miDirectiva() {
  return {
    scope: {},
    controller: function (MyService) {
      this.productos = MyService.getData();
    },
    controllerAs: "vm",
    template: [
      "<h1>Listado de Productos</h1>",
      "<ul>",
      '<mi-item ng-repeat="producto in vm.productos" data="producto">',
      "</mi-item>",
      "</ul>",
    ].join(""),
  };
}
```

Ahora debemos implementar `<mi-item>` teniendo en cuenta el atributo data.

칄sta directiva no necesita controlador porque ya le pasamos los datos dentro del `scope` interno.

Para [**pasar datos entre directivas** ya escrib칤 un art칤culo anterior](/como-pasar-variables-como-atributos-en-directivas-de-angularjs/) que te invito a que le des un vistazo para saber cu치ndo utilizar `=`, `@` o `&`. En este caso asocio el atributo `data` con `=` porque no le paso los datos desde una expresi칩n con doble llave `{{ ... }}`, si no como variable.

Dentro del template de la directiva puedo usar ese `data` para acceder a los datos.

```javascript
function miItem() {
  return {
    scope: {
      data: "=",
    },
    template: [
      "<li>",
      "<strong>{{ data.titulo }}</strong>: ",
      "{{ data.precio | currency }}",
      "</li>",
    ].join(""),
  };
}
```

El c칩digo completo del `app.js` con las dos directivas ser치:

```javascript
angular
  .module("myApp", ["ngRoute"])
  .config(appConfig)
  .service("MyService", MyService)
  .directive("miItem", miItem)
  .directive("miDirectiva", miDirectiva);

function appConfig($routeProvider) {
  $routeProvider.when("/", {
    template: "<mi-directiva></mi-directiva>",
  });
}

function miDirectiva() {
  return {
    scope: {},
    controller: function (MyService) {
      this.productos = MyService.getData();
    },
    controllerAs: "vm",
    template: [
      "<h1>Listado de Productos</h1>",
      "<ul>",
      '<mi-item ng-repeat="producto in vm.productos" data="producto">',
      "</mi-item>",
      "</ul>",
    ].join(""),
  };
}

function miItem() {
  return {
    scope: {
      data: "=",
    },
    template: [
      "<li>",
      "<strong>{{ data.titulo }}</strong>: ",
      "{{ data.precio | currency }}",
      "</li>",
    ].join(""),
  };
}

function MyService() {
  return {
    getData: getData,
  };

  function getData() {
    var datos = [
      { titulo: "Producto 1", precio: 2 },
      { titulo: "Producto 2", precio: 1.5 },
      { titulo: "Producto 3", precio: 4.2 },
      { titulo: "Producto 4", precio: 3 },
      { titulo: "Producto 5", precio: 2.5 },
    ];
    return datos;
  }
}
```

## Conclusi칩n

쯇or qu칠 seguimos esta forma de programar?

En las pr칩ximas versiones de Angular 1.x (la 1.5 y 1.6 al menos) tendremos novedades que nos permitir치n adaptarnos a la versi칩n 2.

Una de ellas es [el nuevo router](/-el-nuevo-router-de-angular-ngnewrouter/). Actualmente est치 como una librer칤a aparte que surgi칩 cuando la versi칩n 1.4, pero se prev칠 que se incluya en la versi칩n 1.5 (actualmente en beta)

Este nuevo router funciona orientado a componentes, por lo que tendr칤amos un c칩digo de configuraci칩n similar a 칠ste:

```
angular
  .module('myApp', ['ngNewRouter'])
  .controller('AppController', AppController);

function AppController($router) {
  $router.config([
    { path: '/', component: 'miDirectiva' }
  ])
}
```

Y tambi칠n en Angular 1.5 tendremos el m칠todo `component` que sustituye de alguna forma a `directive` como vemos en [칠ste art칤culo de Todd Motto](http://toddmotto.com/)

```javascript
// En forma de directiva
angular.module("myApp").directive("miDirectiva", miDirectiva);

function miDirectiva() {
  return {
    scope: {},
    controller: function (MyService) {
      this.productos = MyService.getData();
    },
    controllerAs: "vm",
    template: [
      "<h1>Listado de Productos</h1>",
      "<ul>",
      '<mi-item ng-repeat="producto in vm.productos" data="producto">',
      "</mi-item>",
      "</ul>",
    ].join(""),
  };
}
```

```javascript
// En forma de componente
angular.module("myApp").component("miDirectiva", {
  controller: function (MyService) {
    this.productos = MyService.getData();
  },
  template: [
    "<h1>Listado de Productos</h1>",
    "<ul>",
    '<mi-item ng-repeat="producto in vm.productos" data="producto">',
    "</mi-item>",
    "</ul>",
  ].join(""),
});
```

De momento, esto 칰ltimo est치 en fase beta y a칰n no funciona correctamente, pero ser치n las pr칩ximas novedades.

Por tanto, **programar orientado a directivas (o componentes)** aparte de ser una buena pr치ctica nos **permite prepararnos para las nuevas versiones** de AngularJS (1.5 y 1.6 al menos) y la nueva 2.0, adem치s de utilizar la nueva metodolog칤a de **componentizar nuestras aplicaciones**.

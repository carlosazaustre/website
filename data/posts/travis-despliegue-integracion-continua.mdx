---
title: "C칩mo configurar Travis como herramienta para Integraci칩n y Despliegue continuo"
date: "2020-02-29"
banner: "/images/travis-despliegue-integracion-continua/travis-seo.png"
tags:
  - "游눹 Desarrollo"
---

Integraci칩n Continua o _Continuous Integration (CI)_ y el Despliegue Continuo o _Continuous Deployment_ son dos t칠rminos que suelen ser mencionados juntos. Se refiere a una serie de tareas repetitivas como son testing, building y desplegar a producci칩n una aplicaci칩n/web/software.

Por qu칠 esto es importante. Imagina que tienes el c칩digo de tu app o librer칤a _open source_ en Github, la gente la usa, descarga, prueba, etc... y en alg칰n momento alguien hace un _fork_ y env칤a una _pull request_ para a침adir una nueva funcionalidad, corregir alg칰n bug, etc... De primeras, hacer esto manual solo te lleva un poco de tiempo, pero a la larga vas a querer automatizar esto, para centrarte en tu c칩digo y delegar las tareas que puedan ser "programadas".

## C칩mo funciona

### Integraci칩n Continua (CI)

Este proceso sirve para cuando un determinado software est치 desarrollado por varias personas y queremos automatizar su integraci칩n siguiendo el siguiente procedimiento:

1 - Subimos nuestros cambios en una rama a Github
2 - Un proceso se dispara
3 - La rama es descargada, se construye el software, y se corren los tests.
4 - El resultado se env칤a a d칩nde decidamos.

Si los test son OK, esto significa que el c칩digo puede ser _mergeado_ de forma segura.

### Despliegue Continuo (CD)

Este proceso se utiliza mayormente cuando mergeamos una rama a m치ster:

1 - Se corren los test (idealmente de tipo E2E y m치s exahustivos que los que se hacen en CI)
2 - Se construye y dependiendo del tipo (app, librer칤a, etc...) se har치 una cosa u otra.
3 - Se despliega a un entorno de producci칩n o pre-producci칩n (_staging_, QA,...)

## C칩mo configurar este proceso

Hay varias herramientas y _SaaS_ que te permiten configurar un entorno de integraci칩n y despliegue continuo. En este tutorial te voy a ense침ar a configurarlo con Github y [Travis CI](https://travis-ci.org)

![logo travis](/images/travis-despliegue-integracion-continua/logo-travis.png)

### Repositorio

Lo primero que necesitas es tener to c칩digo en un repositorio. Si tu proyecto es _open source_, puedes usar [Github](https://github.com) y dejarlo libre sin costo, y eso te permite usar la versi칩n _Open_ de Travis, para repositorios p칰blicos.

### Conectar Travis CI a tu repositorio

Una vez tengas tu repo creado, dir칤gete a [Travis-CI](https://travis-ci.org) e inicia sesi칩n con tu cuenta de Github, esto permite a Travis ver tu lista de repos.
Busca el que quieres configurar y activalo con el switch a verde y despues clicka en _settings_.

![lista de repos](/images/travis-despliegue-integracion-continua/travis-01.png)

En las _settings_ te recomiendo que actives las opciones _Build pushed branches_ y _Build pushed pull requests_ para que Travis se ejecute en las PR que generes o te env칤e y tambien cuando 칠stas sean aceptadas y mergeadas a master.

### Fichero de configuraci칩n

Aqu칤 es donde entra la magia. Con un simple fichero que llamaremos `.travis.yml` y alojaremos en la raiz de nuestro proyecto, vamos a decirle a Travis lo que vamos a hacer. Al principio es un poco lioso, pero voy a explicarte paso a paso como hacerlo:

Veamos un ejemplo muy simple:

```yaml
language: node_js
node_js: "12"
script:
  - "npm run lint"
  - "npm test"
  - "npm run build"
```

쯈u칠 estamos diciendo aqu칤?

- `language`: Si trabajamos con Javascript, lo m치s com칰n es decirle que es `node_js` y as칤 Travis crea una _maquina virtual_ preparada para correr Node.js
- `node_js`: C칩mo estamos usando Node/Javascript, tenemos que indicar que versi칩n o versiones nos interesa que se pruebe nuestro software. En este caso le decimos que lo pruebe en `Node.js v12`
- `script`: Aqu칤 pondremos la series de comandos que queramos que se ejecuten en el entorno que crea Travis. como ejemplo he puesto un `npm run lint` que corra ESLint por ejemplo, `npm test` para que ejecute una bateria de tests que tengamos preparados, y por 칰ltimo `npm run build` que contruir칤a la versi칩n de producci칩n de nuestra app/librer칤a o software en general.

Si alguno de estos scripts fallase, Travis abortar칤a el proceso. S칩lo sera OK si todos los scripts no reportan ning칰n fallo.

### El proceso de integraci칩n continua.

Todo este proceso es para asegurarnos de que no rompemos nada cuado estamos listos para _mergear_.
Para mi caso particular, [este blog](/gatsby-deploy-firebase) estoy usando `yarn`, por tanto, para poder hacer m치s r치pidas las integraciones, podemos cachear el directorio `yarn` o `npm`, o cualquier otro _package manager_ que utilices. Lo hacemos as칤:

```yaml
language: node_js
node_js: "12"
cache: yarn
script:
  - "npm run lint"
  - "npm test"
  - "npm run build"
```

Ahora, cada vez que hagas un cambio y hagas _push_, Travis disparar치 el proceso de _build_

![Travis haciendo el build](/images/travis-despliegue-integracion-continua/travis-build.png)

Al haber configurando anteriormente el repositorio en Travis, al crear la _pull request_, nos aparecer치 lo siguiente:

![Travis informando en Github](/images/travis-despliegue-integracion-continua/travis-github-info.png)

Dependiendo de las restricciones que pongas al proyecto, yo por ejemplo tengo puedo no poder mergear si Travis no lanza un OK, podr치s mergear o no.

![Travis da el OK, a mergear!](/images/travis-despliegue-integracion-continua/travis-github-ok.png)

En esta etapa, como hemos dicho anteriormente, es recomendable que se ejecuten todos los tests posible: unitarios, de integraci칩n, etc... para asegurarnos de que todo est치 como queremos y no llevarnos sorpresas desagradables al subir a producci칩n.

### El proceso de despliegue cont칤nuo.

Hasta el momento hemos visto como asegurarnos de que la _pull request_ que hacemos, es "segura" que no rompe nada. Ahora vamos a ver como hacer un _merge_ en la rama principal y que esto se suba a producci칩n.

Si por ejemplo como en [mi blog](/gatsby-deploy-firebase) queremos realizar el despliegue a Firebase, estos son los comandos que deber칤amos a침adir a nuestro fichero `yaml`:

```yaml
install:
  - yarn global add firebase-tools
after_success:
  - firebase deploy --token=${FIREBASE_API_TOKEN}
```

Aqu칤 estamos instalando de forma global las `firebase-tools` en la m치quina virtual que crea travis, para poder utilizar el comando `firebase` que nos permitir치 desplegar.

El token `FIREBASE_API_TOKEN` lo podemos configurar como variable de entorno en Travis dentro de la configuraci칩n del proyecto.

![variables de entorno en travis](/images/travis-despliegue-integracion-continua/travis-env-vars.png)

El fichero `.travis.yml` tiene esta pinta hasta ahora:

```yaml
language: node_js
node_js: "12"
cache: yarn
script:
  - "npm run lint"
  - "npm test"
  - "npm run build"
install:
  - yarn global add firebase-tools
after_success:
  - firebase deploy --token=${FIREBASE_API_TOKEN}
```

Tal como est치 ahora, cada vez que hacemos _push_ de una rama que pasa los tests, estos cambios ser치n desplegados en producci칩n.

Pero... esto tiene un problema. Cualquiera que haga un _pull-request_, sin que lo aceptemos o mergeemos, si pasa los tests, se subir치 a producci칩n de forma autom치tica. 쯇or qu칠 es un problema? porque si, puede que pase los tests, pero se puede estar a침adiendo algo o borrando que no queramos y necesitamos verificarlo.

Por tanto lo mejor es que la integraci칩n y el despliegue est칠n separados.

### Jobs

Hay una funcionalidad en Travis, llamada _job_, es b치sicamente un proceso que corre en la m치quina virtual. Travis nos permite crear m칰ltiples _jobs_ y definir etapas o _stages_ para cada uno de ellos. De esta manera podemos usar condicionales y operar con ellos seg칰n nuestro inter칠s.

```yaml
language: node_js
node_js: 12
cache: yarn
jobs:
  include:
    - stage: test
      script:
        - "npm run lint"
        - "npm test"
        - "npm run build"
    - stage: deploy
      script:
        - yarn global add firebase-tools
        - firebase deploy --token=${FIREBASE_API_TOKEN}
```

쯈u칠 hemos cambiado? Hemos a침adido la propiedad `jobs` con dos etapas: `test` y `deploy`
La primer ejecuta los test para asegurar la integraci칩n y la segunda el despligue a Firebase.

Con esto hemos separado los dos procesos, pero todav칤a nos sigue pasando lo mismo que antes, por cada _PR_ se ejecutar치 todo y se desplegar치 si no hay errores.

Es momento de indicar que debe hacer cada etapa:

```yaml
stages:
  - name: test
    if: type = pull_request
  - name: deploy
    if: type = push AND branch = master
```

Esta nueva propiedad, `stages` nos ayuda a definir condiciones para ejecutar cada etapa de nuestra configuraci칩n. S칩lo queremos que ejecute la etapa de `test` si es una _pull request_, y que se ejecute el `deploy` si se trata de un _push_ a _master_ (el _merge_ del PR a _master_)

De 칠sta forma nos aseguramos que 칰nicamente _pusheando_ una rama a nuestro repositorio en Github, nada se ejecutar치 hasta que no abramos una _pull request_, de igual manera, la etapa de `deploy` solo se va a ejecutar si es un _push a master_, condici칩n que se cumple cuando mergeamos una _pull request_ aprobada y v치lida.

As칤 quedar칤a al completo el fichero `.travis.yml`

```yaml
language: node_js
node_js: 12
cache: yarn
jobs:
  include:
    - stage: test
      script:
        - "npm run lint"
        - "npm test"
        - "npm run build"
    - stage: deploy
      script:
        - yarn global add firebase-tools
        - firebase deploy --token=${FIREBASE_API_TOKEN}
stages:
  - name: test
    if: type = pull_request
  - name: deploy
    if: type = push AND branch = master
```

## Resumen

Ahora ya sabes como configurar Travis en tu proyecto para tener CI/CD (Integraci칩n y Despliegue cont칤nuos) de manera que los tests se ejecuten cuando se abra una _pull request_, y una vez la aceptemos y Travis de el OK, poderla mergear en _master_ y desplegar los cambios en producci칩n o el entorno que elijas.
